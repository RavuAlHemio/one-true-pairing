use proc_macro2::{Ident, Literal, Span, TokenStream};
use quote::quote;

use crate::model::{ArgType, Interface, Protocol};


pub struct Tokenizer {
    pub asynchronous: bool,
    pub in_crate: bool,
}
impl Tokenizer {
    pub fn new(
        asynchronous: bool,
        in_crate: bool,
    ) -> Self {
        Self {
            asynchronous,
            in_crate,
        }
    }

    fn async_tokens(&self) -> TokenStream {
        if self.asynchronous {
            quote! { async }
        } else {
            TokenStream::new()
        }
    }

    fn return_future_tokens_before(&self) -> TokenStream {
        if self.asynchronous {
            quote! { impl ::std::future::Future<Output = }
        } else {
            TokenStream::new()
        }
    }

    fn return_future_tokens_after(&self) -> TokenStream {
        if self.asynchronous {
            quote! { > + ::std::marker::Send + ::std::marker::Sync }
        } else {
            TokenStream::new()
        }
    }

    fn value_future_tokens(&self, value: TokenStream) -> TokenStream {
        if self.asynchronous {
            quote! { ::std::future::ready( #value ) }
        } else {
            value
        }
    }

    fn dot_await_tokens(&self) -> TokenStream {
        if self.asynchronous {
            quote! { . await }
        } else {
            TokenStream::new()
        }
    }

    fn namespace_tokens(&self) -> TokenStream {
        if self.in_crate {
            quote! { crate:: }
        } else {
            quote! { ::whale_land:: }
        }
    }

    pub fn protocol_to_code(&self, protocol: &Protocol) -> String {
        let tokens = self.tokenize_protocol(protocol);
        format!("// This file has been autogenerated from a Wayland XML protocol definition.\n\n{}", tokens)
    }

    fn tokenize_protocol(&self, protocol: &Protocol) -> TokenStream {
        //let protocol_name = Ident::new(&protocol.name, Span::call_site());
        let interfaces = protocol.interfaces
            .iter()
            .map(|i| self.tokenize_interface(i));

        quote! {
            #![allow(non_camel_case_types)]

            #( #interfaces )*
        }
    }

    fn tokenize_interface(&self, interface: &Interface) -> TokenStream {
        let interface_name_ver = format!("{}_v{}", interface.name, interface.version);
        let namespace_tokens = self.namespace_tokens();

        let event_handlers = if interface.events.len() > 0 {
            let event_handler_trait_name = Ident::new(
                &format!("{}_event_handler", interface_name_ver),
                Span::call_site(),
            );

            let async_tokens = self.async_tokens();
            let return_future_tokens_before = self.return_future_tokens_before();
            let return_future_tokens_after = self.return_future_tokens_after();
            let empty_value_future_tokens = self.value_future_tokens(quote! { () });
            let dot_await_tokens = self.dot_await_tokens();

            let mut handle_func_prototypes = Vec::with_capacity(interface.events.len());
            let mut match_variants = Vec::with_capacity(interface.events.len());
            for (event_index, event) in interface.events.iter().enumerate() {
                let handle_func_name = Ident::new(
                    &format!("handle_{}", event.name),
                    Span::call_site(),
                );

                let event_index_literal = Literal::usize_unsuffixed(event_index);

                let mut args = Vec::with_capacity(event.args.len());
                let mut arg_names = Vec::with_capacity(event.args.len());
                let mut arg_decoders = Vec::with_capacity(event.args.len());
                for arg in &event.args {
                    let arg_name = Ident::new(&arg.name, Span::call_site());

                    arg_names.push(quote! { #arg_name });

                    if arg.arg_type == ArgType::NewId {
                        // this needs a bit more logic
                        if arg.interface.is_some() {
                            // we know what interface the object fulfills
                            // => we only receive the object ID
                            args.push(quote! {
                                #arg_name : #namespace_tokens NewObjectId
                            });

                            let new_id_uint_name = Ident::new(
                                &format!("__new_id_uint_{}", arg.name),
                                Span::call_site(),
                            );
                            arg_decoders.push(quote! {
                                let #new_id_uint_name = __packet_reader.read_uint()?;
                                let #arg_name = #namespace_tokens NewObjectId(
                                    #namespace_tokens ObjectId::new( #new_id_uint_name )
                                        .ok_or( #namespace_tokens Error::ZeroObjectId )?
                                );
                            });
                        } else {
                            // we do not know the interface
                            // => we receive all the info
                            args.push(quote! {
                                #arg_name : #namespace_tokens NewObject
                            });

                            let new_id_name = Ident::new(
                                &format!("__new_id_{}", arg.name),
                                Span::call_site(),
                            );
                            let new_iface_name = Ident::new(
                                &format!("__new_iface_{}", arg.name),
                                Span::call_site(),
                            );
                            let new_version_name = Ident::new(
                                &format!("__new_version_{}", arg.name),
                                Span::call_site(),
                            );
                            arg_decoders.push(quote! {
                                let #new_iface_name = __packet_reader.read_string()?;
                                let #new_version_name = __packet_reader.read_uint()?;
                                let #new_id_name = __packet_reader.read_uint()?;
                                let #arg_name = #namespace_tokens NewObject {
                                    object_id: #new_id_name ,
                                    interface: #new_iface_name ,
                                    interface_version: #new_version_name ,
                                };
                            });
                        }

                        // the generic logic is of no interest to us
                        continue;
                    }

                    let arg_type = self.tokenize_incoming_arg_type(&arg.arg_type);
                    let arg_type_read_func = self.tokenize_arg_type_read_func(&arg.arg_type);

                    args.push(quote! {
                        #arg_name : #arg_type
                    });

                    arg_decoders.push(quote! {
                        let #arg_name = __packet_reader . #arg_type_read_func ()?;
                    });
                }

                handle_func_prototypes.push(quote! {
                    fn #handle_func_name (&self #(, #args )* )
                        -> #return_future_tokens_before () #return_future_tokens_after ;
                });
                match_variants.push(quote! {
                    #event_index_literal => {
                        let mut __packet_reader = __packet.read();
                        #( #arg_decoders )*
                        __packet_reader.finish()?;
                        self . #handle_func_name (
                            #( #arg_names , )*
                        ) #dot_await_tokens ;
                        Ok(())
                    }
                });
            }

            let handle_event_func = if self.asynchronous {
                quote! {
                    fn handle_event(&self, __packet: #namespace_tokens Packet)
                            -> impl std::future::Future<Output = ::std::result::Result<(), #namespace_tokens Error>> + ::std::marker::Send + ::std::marker::Sync
                            where Self : Sync {
                        async {
                            match __packet.opcode() {
                                #( #match_variants , )*
                                __other => {
                                    self.unknown_event(__packet).await;
                                    Ok(())
                                },
                            }
                        }
                    }
                }
            } else {
                quote! {
                    fn handle_event(&self, __packet: #namespace_tokens Packet)
                            -> ::std::result::Result<(), #namespace_tokens Error> {
                        async {
                            match __packet.opcode() {
                                #( #match_variants , )*
                                __other => {
                                    self.unknown_event(__packet);
                                    Ok(())
                                },
                            }
                        }
                    }
                }
            };

            quote! {
                #[allow(unused)]
                pub trait #event_handler_trait_name : #namespace_tokens protocol::EventHandler {
                    #( #handle_func_prototypes )*

                    fn unknown_event(&self, packet: #namespace_tokens Packet)
                            -> #return_future_tokens_before () #return_future_tokens_after {
                        // do nothing by default
                        let _ = packet;
                        #empty_value_future_tokens
                    }

                    #handle_event_func
                }
            }
        } else {
            TokenStream::new()
        };

        let request_proxies = if interface.requests.len() > 0 {
            let request_proxy_name = Ident::new(
                &format!("{}_request_proxy", interface_name_ver),
                Span::call_site(),
            );

            let mut proxy_funcs = Vec::with_capacity(interface.requests.len());
            for (req_index, req) in interface.requests.iter().enumerate() {
                let req_name = Ident::new(&format!("send_{}", req.name), Span::call_site());
                let req_index_literal = Literal::usize_unsuffixed(req_index);

                let mut args = Vec::with_capacity(req.args.len());
                let mut arg_write_func_calls = Vec::with_capacity(req.args.len());
                for arg in &req.args {
                    let arg_name = Ident::new(&arg.name, Span::call_site());

                    if arg.arg_type == ArgType::NewId {
                        if arg.interface.is_some() {
                            // the other side knows what interface the object fulfills
                            // => we only send the object ID
                            args.push(quote! {
                                #arg_name : #namespace_tokens NewObjectId
                            });
                            arg_write_func_calls.push(quote! {
                                __packet.push_new_id_known_interface( #arg_name );
                            });
                        } else {
                            // we do not know the interface
                            // => we send all the info
                            args.push(quote! {
                                #arg_name : #namespace_tokens NewObject
                            });
                            arg_write_func_calls.push(quote! {
                                __packet.push_new_id_unknown_interface( #arg_name );
                            });
                        }

                        // the generic logic is of no interest to us
                        continue;
                    }

                    let arg_type = self.tokenize_outgoing_arg_type(&arg.arg_type);
                    let arg_write_func = self.tokenize_arg_type_write_func(&arg.arg_type);

                    args.push(quote! {
                        #arg_name : #arg_type
                    });
                    arg_write_func_calls.push(quote! {
                        __packet . #arg_write_func ( #arg_name );
                    });
                }

                proxy_funcs.push(quote! {
                    pub async fn #req_name (&self, __object_id: #namespace_tokens ObjectId #( , #args )* ) -> Result<(), #namespace_tokens Error> {
                        let mut __packet = #namespace_tokens Packet::new(
                            __object_id,
                            #req_index_literal ,
                        );
                        #( #arg_write_func_calls )*
                        self.connection.send_packet(&__packet).await
                    }
                })
            }

            quote! {
                #[allow(unused)]
                pub struct #request_proxy_name <'a> {
                    connection: &'a #namespace_tokens Connection,
                }
                #[allow(unused)]
                impl<'a> #request_proxy_name <'a> {
                    pub fn new(
                        connection: &'a #namespace_tokens Connection,
                    ) -> Self {
                        Self {
                            connection,
                        }
                    }

                    #( #proxy_funcs )*
                }
            }
        } else {
            TokenStream::new()
        };

        quote! {
            #event_handlers
            #request_proxies
        }
    }

    fn tokenize_incoming_arg_type(&self, arg_type: &ArgType) -> TokenStream {
        let namespace_tokens = self.namespace_tokens();
        match arg_type {
            ArgType::Uint => quote! { u32 },
            ArgType::Int => quote! { i32 },
            ArgType::Fixed => quote! { #namespace_tokens Fixed },
            ArgType::String => quote! { ::std::string::String },
            ArgType::ObjectId => quote! { ::std::option::Option< #namespace_tokens ObjectId > },
            ArgType::NewId => quote! { #namespace_tokens ObjectId },
            ArgType::Array => quote! { ::std::vec::Vec<u8> },
            ArgType::FileDescriptor => quote! { ::std::os::fd::RawFd },
        }
    }

    fn tokenize_outgoing_arg_type(&self, arg_type: &ArgType) -> TokenStream {
        match arg_type {
            ArgType::String => quote! { &str },
            ArgType::Array => quote! { &[u8] },
            other => self.tokenize_incoming_arg_type(other),
        }
    }

    fn tokenize_arg_type_read_func(&self, arg_type: &ArgType) -> TokenStream {
        match arg_type {
            ArgType::Uint => quote! { read_uint },
            ArgType::Int => quote! { read_int },
            ArgType::Fixed => quote! { read_fixed },
            ArgType::String => quote! { read_str },
            ArgType::ObjectId => quote! { read_object },
            ArgType::NewId => panic!("ArgType::NewId needs special interface handling"),
            ArgType::Array => quote! { read_array },
            ArgType::FileDescriptor => quote! { read_fd },
        }
    }

    fn tokenize_arg_type_write_func(&self, arg_type: &ArgType) -> TokenStream {
        match arg_type {
            ArgType::Uint => quote! { push_uint },
            ArgType::Int => quote! { push_int },
            ArgType::Fixed => quote! { push_fixed },
            ArgType::String => quote! { push_str },
            ArgType::ObjectId => quote! { push_object },
            ArgType::NewId => panic!("ArgType::NewId needs special interface handling"),
            ArgType::Array => quote! { push_array },
            ArgType::FileDescriptor => quote! { push_fd },
        }
    }
}
