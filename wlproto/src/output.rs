use proc_macro2::{Ident, Literal, Span, TokenStream};
use quote::quote;

use crate::model::{ArgType, Interface, Protocol};


pub struct Tokenizer {
    pub asynchronous: bool,
    pub in_crate: bool,
}
impl Tokenizer {
    pub fn new(
        asynchronous: bool,
        in_crate: bool,
    ) -> Self {
        Self {
            asynchronous,
            in_crate,
        }
    }

    fn return_future_tokens_before(&self) -> TokenStream {
        if self.asynchronous {
            quote! { impl ::std::future::Future<Output = }
        } else {
            TokenStream::new()
        }
    }

    fn return_future_tokens_after(&self) -> TokenStream {
        if self.asynchronous {
            quote! { > + ::std::marker::Send + ::std::marker::Sync }
        } else {
            TokenStream::new()
        }
    }

    fn value_future_tokens(&self, value: TokenStream) -> TokenStream {
        if self.asynchronous {
            quote! { ::std::future::ready( #value ) }
        } else {
            value
        }
    }

    fn dot_await_tokens(&self) -> TokenStream {
        if self.asynchronous {
            quote! { . await }
        } else {
            TokenStream::new()
        }
    }

    fn namespace_tokens(&self) -> TokenStream {
        if self.in_crate {
            quote! { crate:: }
        } else {
            quote! { ::whale_land:: }
        }
    }

    pub fn protocol_to_code(&self, protocol: &Protocol) -> String {
        let tokens = self.tokenize_protocol(protocol);
        format!("// This file has been autogenerated from a Wayland XML protocol definition.\n\n{}", tokens)
    }

    fn tokenize_protocol(&self, protocol: &Protocol) -> TokenStream {
        //let protocol_name = Ident::new(&protocol.name, Span::call_site());
        let interfaces = protocol.interfaces
            .iter()
            .map(|i| self.tokenize_interface(i));

        quote! {
            #![allow(non_camel_case_types)]

            #( #interfaces )*
        }
    }

    fn tokenize_interface(&self, interface: &Interface) -> TokenStream {
        let interface_name_ver = format!("{}_v{}", interface.name, interface.version);
        let namespace_tokens = self.namespace_tokens();

        let event_handlers = if interface.events.len() > 0 {
            let event_handler_trait_name = Ident::new(
                &format!("{}_event_handler", interface_name_ver),
                Span::call_site(),
            );

            let return_future_tokens_before = self.return_future_tokens_before();
            let return_future_tokens_after = self.return_future_tokens_after();
            let empty_value_future_tokens = self.value_future_tokens(quote! { () });
            let dot_await_tokens = self.dot_await_tokens();

            let mut handle_func_prototypes = Vec::with_capacity(interface.events.len());
            let mut match_variants = Vec::with_capacity(interface.events.len());
            for (event_index, event) in interface.events.iter().enumerate() {
                let handle_func_name = Ident::new(
                    &format!("handle_{}", event.name),
                    Span::call_site(),
                );

                let event_index_literal = Literal::usize_unsuffixed(event_index);

                let mut args = Vec::with_capacity(event.args.len());
                let mut arg_names = Vec::with_capacity(event.args.len());
                let mut arg_decoders = Vec::with_capacity(event.args.len());
                for arg in &event.args {
                    let arg_name = Ident::new(&arg.name, Span::call_site());

                    arg_names.push(quote! { #arg_name });

                    let arg_type = self.tokenize_incoming_arg_type(&arg.arg_type, arg.interface.is_some());
                    let arg_type_read_func = self.tokenize_arg_type_read_func(&arg.arg_type, arg.interface.is_some());

                    args.push(quote! {
                        #arg_name : #arg_type
                    });

                    arg_decoders.push(quote! {
                        let #arg_name = __packet_reader . #arg_type_read_func ()?;
                    });
                }

                handle_func_prototypes.push(quote! {
                    fn #handle_func_name (
                        &self,
                        connection: & #namespace_tokens Connection,
                        packet: #namespace_tokens Packet,
                        #( #args , )*
                    )
                        -> #return_future_tokens_before () #return_future_tokens_after ;
                });
                match_variants.push(quote! {
                    #event_index_literal => {
                        let mut __packet_reader = __packet.read();
                        #( #arg_decoders )*
                        __packet_reader.finish()?;
                        self . #handle_func_name (
                            __connection,
                            __packet,
                            #( #arg_names , )*
                        ) #dot_await_tokens ;
                        Ok(())
                    }
                });
            }

            let handle_event_func = if self.asynchronous {
                quote! {
                    fn handle_event(
                        &self,
                        __connection: & #namespace_tokens Connection,
                        __packet: #namespace_tokens Packet,
                    ) -> impl std::future::Future<Output = ::std::result::Result<(), #namespace_tokens Error>> + ::std::marker::Send + ::std::marker::Sync
                            where Self : Sync {
                        async {
                            match __packet.opcode() {
                                #( #match_variants , )*
                                __other => {
                                    self.unknown_event(__connection, __packet).await;
                                    Ok(())
                                },
                            }
                        }
                    }
                }
            } else {
                quote! {
                    fn handle_event(
                        &self,
                        __connection: & #namespace_tokens Connection,
                        __packet: #namespace_tokens Packet,
                    ) -> ::std::result::Result<(), #namespace_tokens Error> {
                        async {
                            match __packet.opcode() {
                                #( #match_variants , )*
                                __other => {
                                    self.unknown_event(__connection, __packet);
                                    Ok(())
                                },
                            }
                        }
                    }
                }
            };

            quote! {
                #[allow(unused)]
                pub trait #event_handler_trait_name : #namespace_tokens protocol::EventHandler {
                    #( #handle_func_prototypes )*

                    fn unknown_event(&self, connection: & #namespace_tokens Connection, packet: #namespace_tokens Packet)
                            -> #return_future_tokens_before () #return_future_tokens_after {
                        // do nothing by default
                        let _ = connection;
                        let _ = packet;
                        #empty_value_future_tokens
                    }

                    #handle_event_func
                }
            }
        } else {
            TokenStream::new()
        };

        let request_proxies = if interface.requests.len() > 0 {
            let request_proxy_name = Ident::new(
                &format!("{}_request_proxy", interface_name_ver),
                Span::call_site(),
            );

            let mut proxy_funcs = Vec::with_capacity(interface.requests.len());
            for (req_index, req) in interface.requests.iter().enumerate() {
                let req_name = Ident::new(&format!("send_{}", req.name), Span::call_site());
                let req_index_literal = Literal::usize_unsuffixed(req_index);

                let mut args = Vec::with_capacity(req.args.len());
                let mut arg_write_func_calls = Vec::with_capacity(req.args.len());
                for arg in &req.args {
                    let arg_name = Ident::new(&arg.name, Span::call_site());

                    let arg_type = self.tokenize_outgoing_arg_type(&arg.arg_type, arg.interface.is_some());
                    let arg_write_func = self.tokenize_arg_type_write_func(&arg.arg_type, arg.interface.is_some());
                    let arg_write_ref = self.tokenize_arg_type_write_reference(&arg.arg_type, arg.interface.is_some());

                    args.push(quote! {
                        #arg_name : #arg_type
                    });
                    arg_write_func_calls.push(quote! {
                        __packet . #arg_write_func ( #arg_write_ref #arg_name );
                    });
                }

                proxy_funcs.push(quote! {
                    pub async fn #req_name (&self, __object_id: #namespace_tokens ObjectId #( , #args )* ) -> Result<(), #namespace_tokens Error> {
                        let mut __packet = #namespace_tokens Packet::new(
                            __object_id,
                            #req_index_literal ,
                        );
                        #( #arg_write_func_calls )*
                        self.connection.send_packet(&__packet).await
                    }
                })
            }

            quote! {
                #[allow(unused)]
                pub struct #request_proxy_name <'a> {
                    connection: &'a #namespace_tokens Connection,
                }
                #[allow(unused)]
                impl<'a> #request_proxy_name <'a> {
                    pub fn new(
                        connection: &'a #namespace_tokens Connection,
                    ) -> Self {
                        Self {
                            connection,
                        }
                    }

                    #( #proxy_funcs )*
                }
            }
        } else {
            TokenStream::new()
        };

        let mut arg_structs = Vec::new();
        let request_iterator = interface.requests
            .iter()
            .enumerate()
            .map(|(i, e)| (i, "request", e));
        let event_iterator = interface.events
            .iter()
            .enumerate()
            .map(|(i, e)| (i, "event", e));
        for (i, kind, procedure) in request_iterator.chain(event_iterator) {
            let arg_struct_name = Ident::new(
                &format!("{}_{}_{}_args", interface_name_ver, kind, procedure.name),
                Span::call_site(),
            );
            let opcode = Literal::usize_unsuffixed(i);

            let mut fields = Vec::with_capacity(procedure.args.len());
            let mut field_reads = Vec::with_capacity(procedure.args.len());
            let mut field_names = Vec::with_capacity(procedure.args.len());
            let mut field_writes = Vec::with_capacity(procedure.args.len());
            for arg in &procedure.args {
                let field_name = Ident::new(
                    &arg.name,
                    Span::call_site(),
                );
                field_names.push(field_name.clone());
                let field_type = self.tokenize_incoming_arg_type(&arg.arg_type, arg.interface.is_some());
                fields.push(quote! { #field_name : #field_type });
                let read_name = self.tokenize_arg_type_read_func(&arg.arg_type, arg.interface.is_some());
                field_reads.push(quote! { let #field_name = __reader. #read_name ()?; });
                let write_name = self.tokenize_arg_type_write_func(&arg.arg_type, arg.interface.is_some());
                let write_reference = self.tokenize_arg_type_write_reference(&arg.arg_type, arg.interface.is_some());
                field_writes.push(quote! { __packet . #write_name ( #write_reference self. #field_name ); });
            }

            arg_structs.push(quote! {
                pub struct #arg_struct_name {
                    #( #fields , )*
                }
                impl #arg_struct_name {
                    pub const OPCODE: u16 = #opcode ;

                    pub fn try_from_packet(__value: & #namespace_tokens Packet) -> Result< #arg_struct_name , #namespace_tokens Error > {
                        let mut __reader = __value.read();
                        #( #field_reads )*
                        __reader.finish()?;
                        Ok(Self {
                            #( #field_names , )*
                        })
                    }

                    pub fn try_into_packet(&self, __object_id: #namespace_tokens ObjectId) -> Result< #namespace_tokens Packet , #namespace_tokens Error > {
                        let mut __packet = #namespace_tokens Packet::new(__object_id, Self::OPCODE);
                        #( #field_writes )*
                        Ok(__packet)
                    }
                }
                impl ::std::convert::TryFrom< #namespace_tokens Packet > for #arg_struct_name {
                    type Error = #namespace_tokens Error;
                    fn try_from(__value: #namespace_tokens Packet) -> Result<Self, Self::Error> {
                        Self::try_from_packet(&__value)
                    }
                }
                impl ::std::convert::TryFrom<( #namespace_tokens ObjectId, #arg_struct_name )> for #namespace_tokens Packet {
                    type Error = #namespace_tokens Error;
                    fn try_from(__value: ( #namespace_tokens ObjectId, #arg_struct_name )) -> Result<Self, Self::Error> {
                        let (__object_id, __structure) = __value;
                        __structure.try_into_packet(__object_id)
                    }
                }
            });
        }

        quote! {
            #event_handlers
            #request_proxies
            #( #arg_structs )*
        }
    }

    fn tokenize_incoming_arg_type(&self, arg_type: &ArgType, known_interface: bool) -> TokenStream {
        let namespace_tokens = self.namespace_tokens();
        match arg_type {
            ArgType::Uint => quote! { u32 },
            ArgType::Int => quote! { i32 },
            ArgType::Fixed => quote! { #namespace_tokens Fixed },
            ArgType::String => quote! { ::std::string::String },
            ArgType::ObjectId => quote! { ::std::option::Option< #namespace_tokens ObjectId > },
            ArgType::NewId => if known_interface {
                quote! { #namespace_tokens NewObjectId }
            } else {
                quote! { #namespace_tokens NewObject }
            },
            ArgType::Array => quote! { ::std::vec::Vec<u8> },
            ArgType::FileDescriptor => quote! { ::std::os::fd::RawFd },
        }
    }

    fn tokenize_outgoing_arg_type(&self, arg_type: &ArgType, known_interface: bool) -> TokenStream {
        match arg_type {
            ArgType::String => quote! { &str },
            ArgType::Array => quote! { &[u8] },
            other => self.tokenize_incoming_arg_type(other, known_interface),
        }
    }

    fn tokenize_arg_type_read_func(&self, arg_type: &ArgType, known_interface: bool) -> TokenStream {
        match arg_type {
            ArgType::Uint => quote! { read_uint },
            ArgType::Int => quote! { read_int },
            ArgType::Fixed => quote! { read_fixed },
            ArgType::String => quote! { read_str },
            ArgType::ObjectId => quote! { read_object },
            ArgType::NewId => if known_interface {
                quote! { read_new_id_known_interface }
            } else {
                quote! { read_new_id_unknown_interface }
            },
            ArgType::Array => quote! { read_array },
            ArgType::FileDescriptor => quote! { read_fd },
        }
    }

    fn tokenize_arg_type_write_func(&self, arg_type: &ArgType, known_interface: bool) -> TokenStream {
        match arg_type {
            ArgType::Uint => quote! { push_uint },
            ArgType::Int => quote! { push_int },
            ArgType::Fixed => quote! { push_fixed },
            ArgType::String => quote! { push_str },
            ArgType::ObjectId => quote! { push_object },
            ArgType::NewId => if known_interface {
                quote! { push_new_id_known_interface }
            } else {
                quote! { push_new_id_unknown_interface }
            },
            ArgType::Array => quote! { push_array },
            ArgType::FileDescriptor => quote! { push_fd },
        }
    }

    fn tokenize_arg_type_write_reference(&self, arg_type: &ArgType, known_interface: bool) -> TokenStream {
        match arg_type {
            ArgType::Uint|ArgType::Int|ArgType::Fixed|ArgType::ObjectId
                |ArgType::FileDescriptor => quote! { },
            ArgType::String|ArgType::Array => quote! { & },
            ArgType::NewId => if known_interface {
                quote! { }
            } else {
                quote! { & }
            },
        }
    }
}
