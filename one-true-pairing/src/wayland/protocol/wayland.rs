// This file has been autogenerated from a Wayland XML protocol definition.

#![allow(non_camel_case_types)]
#[allow(unused)]
pub trait wl_display_v1_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_error(
        &self,
        object_id: ::std::option::Option<crate::wayland::ObjectId>,
        code: u32,
        message: ::std::string::String,
    );
    async fn handle_delete_id(&self, id: u32);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                let object_id = __packet_reader.read_object()?;
                let code = __packet_reader.read_uint()?;
                let message = __packet_reader.read_str()?;
                __packet_reader.finish()?;
                self.handle_error(object_id, code, message).await;
                Ok(())
            }
            1 => {
                let mut __packet_reader = __packet.read();
                let id = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_delete_id(id).await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_display_v1_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_display_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_sync(
        &self,
        __object_id: crate::wayland::ObjectId,
        callback: crate::wayland::NewObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(callback);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_registry(
        &self,
        __object_id: crate::wayland::ObjectId,
        registry: crate::wayland::NewObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(registry);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_registry_v1_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_global(&self, name: u32, interface: ::std::string::String, version: u32);
    async fn handle_global_remove(&self, name: u32);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                let name = __packet_reader.read_uint()?;
                let interface = __packet_reader.read_str()?;
                let version = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_global(name, interface, version).await;
                Ok(())
            }
            1 => {
                let mut __packet_reader = __packet.read();
                let name = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_global_remove(name).await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_registry_v1_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_registry_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_bind(
        &self,
        __object_id: crate::wayland::ObjectId,
        name: u32,
        id: crate::wayland::NewObject,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        __packet.push_uint(name);
        __packet.push_new_id_unknown_interface(id);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_callback_v1_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_done(&self, callback_data: u32);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                let callback_data = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_done(callback_data).await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_compositor_v6_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_compositor_v6_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_create_surface(
        &self,
        __object_id: crate::wayland::ObjectId,
        id: crate::wayland::NewObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_create_region(
        &self,
        __object_id: crate::wayland::ObjectId,
        id: crate::wayland::NewObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub struct wl_shm_pool_v2_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_shm_pool_v2_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_create_buffer(
        &self,
        __object_id: crate::wayland::ObjectId,
        id: crate::wayland::NewObjectId,
        offset: i32,
        width: i32,
        height: i32,
        stride: i32,
        format: u32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        __packet.push_int(offset);
        __packet.push_int(width);
        __packet.push_int(height);
        __packet.push_int(stride);
        __packet.push_uint(format);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_resize(
        &self,
        __object_id: crate::wayland::ObjectId,
        size: i32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 2);
        __packet.push_int(size);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_shm_v2_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_format(&self, format: u32);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                let format = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_format(format).await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_shm_v2_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_shm_v2_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_create_pool(
        &self,
        __object_id: crate::wayland::ObjectId,
        id: crate::wayland::NewObjectId,
        fd: ::std::os::fd::RawFd,
        size: i32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        __packet.push_fd(fd);
        __packet.push_int(size);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_release(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_buffer_v1_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_release(&self);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                __packet_reader.finish()?;
                self.handle_release().await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_buffer_v1_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_buffer_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_data_offer_v3_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_offer(&self, mime_type: ::std::string::String);
    async fn handle_source_actions(&self, source_actions: u32);
    async fn handle_action(&self, dnd_action: u32);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                let mime_type = __packet_reader.read_str()?;
                __packet_reader.finish()?;
                self.handle_offer(mime_type).await;
                Ok(())
            }
            1 => {
                let mut __packet_reader = __packet.read();
                let source_actions = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_source_actions(source_actions).await;
                Ok(())
            }
            2 => {
                let mut __packet_reader = __packet.read();
                let dnd_action = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_action(dnd_action).await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_data_offer_v3_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_data_offer_v3_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_accept(
        &self,
        __object_id: crate::wayland::ObjectId,
        serial: u32,
        mime_type: &str,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        __packet.push_uint(serial);
        __packet.push_str(mime_type);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_receive(
        &self,
        __object_id: crate::wayland::ObjectId,
        mime_type: &str,
        fd: ::std::os::fd::RawFd,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        __packet.push_str(mime_type);
        __packet.push_fd(fd);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 2);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_finish(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 3);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_actions(
        &self,
        __object_id: crate::wayland::ObjectId,
        dnd_actions: u32,
        preferred_action: u32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 4);
        __packet.push_uint(dnd_actions);
        __packet.push_uint(preferred_action);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_data_source_v3_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_target(&self, mime_type: ::std::string::String);
    async fn handle_send(&self, mime_type: ::std::string::String, fd: ::std::os::fd::RawFd);
    async fn handle_cancelled(&self);
    async fn handle_dnd_drop_performed(&self);
    async fn handle_dnd_finished(&self);
    async fn handle_action(&self, dnd_action: u32);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                let mime_type = __packet_reader.read_str()?;
                __packet_reader.finish()?;
                self.handle_target(mime_type).await;
                Ok(())
            }
            1 => {
                let mut __packet_reader = __packet.read();
                let mime_type = __packet_reader.read_str()?;
                let fd = __packet_reader.read_fd()?;
                __packet_reader.finish()?;
                self.handle_send(mime_type, fd).await;
                Ok(())
            }
            2 => {
                let mut __packet_reader = __packet.read();
                __packet_reader.finish()?;
                self.handle_cancelled().await;
                Ok(())
            }
            3 => {
                let mut __packet_reader = __packet.read();
                __packet_reader.finish()?;
                self.handle_dnd_drop_performed().await;
                Ok(())
            }
            4 => {
                let mut __packet_reader = __packet.read();
                __packet_reader.finish()?;
                self.handle_dnd_finished().await;
                Ok(())
            }
            5 => {
                let mut __packet_reader = __packet.read();
                let dnd_action = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_action(dnd_action).await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_data_source_v3_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_data_source_v3_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_offer(
        &self,
        __object_id: crate::wayland::ObjectId,
        mime_type: &str,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        __packet.push_str(mime_type);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_actions(
        &self,
        __object_id: crate::wayland::ObjectId,
        dnd_actions: u32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 2);
        __packet.push_uint(dnd_actions);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_data_device_v3_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_data_offer(&self, id: crate::wayland::NewObjectId);
    async fn handle_enter(
        &self,
        serial: u32,
        surface: ::std::option::Option<crate::wayland::ObjectId>,
        x: crate::wayland::Fixed,
        y: crate::wayland::Fixed,
        id: ::std::option::Option<crate::wayland::ObjectId>,
    );
    async fn handle_leave(&self);
    async fn handle_motion(&self, time: u32, x: crate::wayland::Fixed, y: crate::wayland::Fixed);
    async fn handle_drop(&self);
    async fn handle_selection(&self, id: ::std::option::Option<crate::wayland::ObjectId>);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                let __new_id_uint_id = __packet_reader.read_uint()?;
                let id = crate::wayland::NewObjectId(
                    crate::wayland::ObjectId::new(__new_id_uint_id)
                        .ok_or(crate::wayland::Error::ZeroObjectId)?,
                );
                __packet_reader.finish()?;
                self.handle_data_offer(id).await;
                Ok(())
            }
            1 => {
                let mut __packet_reader = __packet.read();
                let serial = __packet_reader.read_uint()?;
                let surface = __packet_reader.read_object()?;
                let x = __packet_reader.read_fixed()?;
                let y = __packet_reader.read_fixed()?;
                let id = __packet_reader.read_object()?;
                __packet_reader.finish()?;
                self.handle_enter(serial, surface, x, y, id).await;
                Ok(())
            }
            2 => {
                let mut __packet_reader = __packet.read();
                __packet_reader.finish()?;
                self.handle_leave().await;
                Ok(())
            }
            3 => {
                let mut __packet_reader = __packet.read();
                let time = __packet_reader.read_uint()?;
                let x = __packet_reader.read_fixed()?;
                let y = __packet_reader.read_fixed()?;
                __packet_reader.finish()?;
                self.handle_motion(time, x, y).await;
                Ok(())
            }
            4 => {
                let mut __packet_reader = __packet.read();
                __packet_reader.finish()?;
                self.handle_drop().await;
                Ok(())
            }
            5 => {
                let mut __packet_reader = __packet.read();
                let id = __packet_reader.read_object()?;
                __packet_reader.finish()?;
                self.handle_selection(id).await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_data_device_v3_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_data_device_v3_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_start_drag(
        &self,
        __object_id: crate::wayland::ObjectId,
        source: ::std::option::Option<crate::wayland::ObjectId>,
        origin: ::std::option::Option<crate::wayland::ObjectId>,
        icon: ::std::option::Option<crate::wayland::ObjectId>,
        serial: u32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        __packet.push_object(source);
        __packet.push_object(origin);
        __packet.push_object(icon);
        __packet.push_uint(serial);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_selection(
        &self,
        __object_id: crate::wayland::ObjectId,
        source: ::std::option::Option<crate::wayland::ObjectId>,
        serial: u32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        __packet.push_object(source);
        __packet.push_uint(serial);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_release(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 2);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub struct wl_data_device_manager_v3_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_data_device_manager_v3_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_create_data_source(
        &self,
        __object_id: crate::wayland::ObjectId,
        id: crate::wayland::NewObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_data_device(
        &self,
        __object_id: crate::wayland::ObjectId,
        id: crate::wayland::NewObjectId,
        seat: ::std::option::Option<crate::wayland::ObjectId>,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(id);
        __packet.push_object(seat);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub struct wl_shell_v1_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_shell_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_get_shell_surface(
        &self,
        __object_id: crate::wayland::ObjectId,
        id: crate::wayland::NewObjectId,
        surface: ::std::option::Option<crate::wayland::ObjectId>,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        __packet.push_object(surface);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_shell_surface_v1_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_ping(&self, serial: u32);
    async fn handle_configure(&self, edges: u32, width: i32, height: i32);
    async fn handle_popup_done(&self);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                let serial = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_ping(serial).await;
                Ok(())
            }
            1 => {
                let mut __packet_reader = __packet.read();
                let edges = __packet_reader.read_uint()?;
                let width = __packet_reader.read_int()?;
                let height = __packet_reader.read_int()?;
                __packet_reader.finish()?;
                self.handle_configure(edges, width, height).await;
                Ok(())
            }
            2 => {
                let mut __packet_reader = __packet.read();
                __packet_reader.finish()?;
                self.handle_popup_done().await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_shell_surface_v1_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_shell_surface_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_pong(
        &self,
        __object_id: crate::wayland::ObjectId,
        serial: u32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        __packet.push_uint(serial);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_move(
        &self,
        __object_id: crate::wayland::ObjectId,
        seat: ::std::option::Option<crate::wayland::ObjectId>,
        serial: u32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        __packet.push_object(seat);
        __packet.push_uint(serial);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_resize(
        &self,
        __object_id: crate::wayland::ObjectId,
        seat: ::std::option::Option<crate::wayland::ObjectId>,
        serial: u32,
        edges: u32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 2);
        __packet.push_object(seat);
        __packet.push_uint(serial);
        __packet.push_uint(edges);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_toplevel(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 3);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_transient(
        &self,
        __object_id: crate::wayland::ObjectId,
        parent: ::std::option::Option<crate::wayland::ObjectId>,
        x: i32,
        y: i32,
        flags: u32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 4);
        __packet.push_object(parent);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_uint(flags);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_fullscreen(
        &self,
        __object_id: crate::wayland::ObjectId,
        method: u32,
        framerate: u32,
        output: ::std::option::Option<crate::wayland::ObjectId>,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 5);
        __packet.push_uint(method);
        __packet.push_uint(framerate);
        __packet.push_object(output);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_popup(
        &self,
        __object_id: crate::wayland::ObjectId,
        seat: ::std::option::Option<crate::wayland::ObjectId>,
        serial: u32,
        parent: ::std::option::Option<crate::wayland::ObjectId>,
        x: i32,
        y: i32,
        flags: u32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 6);
        __packet.push_object(seat);
        __packet.push_uint(serial);
        __packet.push_object(parent);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_uint(flags);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_maximized(
        &self,
        __object_id: crate::wayland::ObjectId,
        output: ::std::option::Option<crate::wayland::ObjectId>,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 7);
        __packet.push_object(output);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_title(
        &self,
        __object_id: crate::wayland::ObjectId,
        title: &str,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 8);
        __packet.push_str(title);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_class(
        &self,
        __object_id: crate::wayland::ObjectId,
        class_: &str,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 9);
        __packet.push_str(class_);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_surface_v6_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_enter(&self, output: ::std::option::Option<crate::wayland::ObjectId>);
    async fn handle_leave(&self, output: ::std::option::Option<crate::wayland::ObjectId>);
    async fn handle_preferred_buffer_scale(&self, factor: i32);
    async fn handle_preferred_buffer_transform(&self, transform: u32);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                let output = __packet_reader.read_object()?;
                __packet_reader.finish()?;
                self.handle_enter(output).await;
                Ok(())
            }
            1 => {
                let mut __packet_reader = __packet.read();
                let output = __packet_reader.read_object()?;
                __packet_reader.finish()?;
                self.handle_leave(output).await;
                Ok(())
            }
            2 => {
                let mut __packet_reader = __packet.read();
                let factor = __packet_reader.read_int()?;
                __packet_reader.finish()?;
                self.handle_preferred_buffer_scale(factor).await;
                Ok(())
            }
            3 => {
                let mut __packet_reader = __packet.read();
                let transform = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_preferred_buffer_transform(transform).await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_surface_v6_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_surface_v6_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_attach(
        &self,
        __object_id: crate::wayland::ObjectId,
        buffer: ::std::option::Option<crate::wayland::ObjectId>,
        x: i32,
        y: i32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        __packet.push_object(buffer);
        __packet.push_int(x);
        __packet.push_int(y);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_damage(
        &self,
        __object_id: crate::wayland::ObjectId,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 2);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_int(width);
        __packet.push_int(height);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_frame(
        &self,
        __object_id: crate::wayland::ObjectId,
        callback: crate::wayland::NewObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 3);
        __packet.push_new_id_known_interface(callback);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_opaque_region(
        &self,
        __object_id: crate::wayland::ObjectId,
        region: ::std::option::Option<crate::wayland::ObjectId>,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 4);
        __packet.push_object(region);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_input_region(
        &self,
        __object_id: crate::wayland::ObjectId,
        region: ::std::option::Option<crate::wayland::ObjectId>,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 5);
        __packet.push_object(region);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_commit(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 6);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_buffer_transform(
        &self,
        __object_id: crate::wayland::ObjectId,
        transform: i32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 7);
        __packet.push_int(transform);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_buffer_scale(
        &self,
        __object_id: crate::wayland::ObjectId,
        scale: i32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 8);
        __packet.push_int(scale);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_damage_buffer(
        &self,
        __object_id: crate::wayland::ObjectId,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 9);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_int(width);
        __packet.push_int(height);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_offset(
        &self,
        __object_id: crate::wayland::ObjectId,
        x: i32,
        y: i32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 10);
        __packet.push_int(x);
        __packet.push_int(y);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_seat_v10_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_capabilities(&self, capabilities: u32);
    async fn handle_name(&self, name: ::std::string::String);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                let capabilities = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_capabilities(capabilities).await;
                Ok(())
            }
            1 => {
                let mut __packet_reader = __packet.read();
                let name = __packet_reader.read_str()?;
                __packet_reader.finish()?;
                self.handle_name(name).await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_seat_v10_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_seat_v10_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_get_pointer(
        &self,
        __object_id: crate::wayland::ObjectId,
        id: crate::wayland::NewObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_keyboard(
        &self,
        __object_id: crate::wayland::ObjectId,
        id: crate::wayland::NewObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_touch(
        &self,
        __object_id: crate::wayland::ObjectId,
        id: crate::wayland::NewObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 2);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_release(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 3);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_pointer_v10_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_enter(
        &self,
        serial: u32,
        surface: ::std::option::Option<crate::wayland::ObjectId>,
        surface_x: crate::wayland::Fixed,
        surface_y: crate::wayland::Fixed,
    );
    async fn handle_leave(
        &self,
        serial: u32,
        surface: ::std::option::Option<crate::wayland::ObjectId>,
    );
    async fn handle_motion(
        &self,
        time: u32,
        surface_x: crate::wayland::Fixed,
        surface_y: crate::wayland::Fixed,
    );
    async fn handle_button(&self, serial: u32, time: u32, button: u32, state: u32);
    async fn handle_axis(&self, time: u32, axis: u32, value: crate::wayland::Fixed);
    async fn handle_frame(&self);
    async fn handle_axis_source(&self, axis_source: u32);
    async fn handle_axis_stop(&self, time: u32, axis: u32);
    async fn handle_axis_discrete(&self, axis: u32, discrete: i32);
    async fn handle_axis_value120(&self, axis: u32, value120: i32);
    async fn handle_axis_relative_direction(&self, axis: u32, direction: u32);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                let serial = __packet_reader.read_uint()?;
                let surface = __packet_reader.read_object()?;
                let surface_x = __packet_reader.read_fixed()?;
                let surface_y = __packet_reader.read_fixed()?;
                __packet_reader.finish()?;
                self.handle_enter(serial, surface, surface_x, surface_y)
                    .await;
                Ok(())
            }
            1 => {
                let mut __packet_reader = __packet.read();
                let serial = __packet_reader.read_uint()?;
                let surface = __packet_reader.read_object()?;
                __packet_reader.finish()?;
                self.handle_leave(serial, surface).await;
                Ok(())
            }
            2 => {
                let mut __packet_reader = __packet.read();
                let time = __packet_reader.read_uint()?;
                let surface_x = __packet_reader.read_fixed()?;
                let surface_y = __packet_reader.read_fixed()?;
                __packet_reader.finish()?;
                self.handle_motion(time, surface_x, surface_y).await;
                Ok(())
            }
            3 => {
                let mut __packet_reader = __packet.read();
                let serial = __packet_reader.read_uint()?;
                let time = __packet_reader.read_uint()?;
                let button = __packet_reader.read_uint()?;
                let state = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_button(serial, time, button, state).await;
                Ok(())
            }
            4 => {
                let mut __packet_reader = __packet.read();
                let time = __packet_reader.read_uint()?;
                let axis = __packet_reader.read_uint()?;
                let value = __packet_reader.read_fixed()?;
                __packet_reader.finish()?;
                self.handle_axis(time, axis, value).await;
                Ok(())
            }
            5 => {
                let mut __packet_reader = __packet.read();
                __packet_reader.finish()?;
                self.handle_frame().await;
                Ok(())
            }
            6 => {
                let mut __packet_reader = __packet.read();
                let axis_source = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_axis_source(axis_source).await;
                Ok(())
            }
            7 => {
                let mut __packet_reader = __packet.read();
                let time = __packet_reader.read_uint()?;
                let axis = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_axis_stop(time, axis).await;
                Ok(())
            }
            8 => {
                let mut __packet_reader = __packet.read();
                let axis = __packet_reader.read_uint()?;
                let discrete = __packet_reader.read_int()?;
                __packet_reader.finish()?;
                self.handle_axis_discrete(axis, discrete).await;
                Ok(())
            }
            9 => {
                let mut __packet_reader = __packet.read();
                let axis = __packet_reader.read_uint()?;
                let value120 = __packet_reader.read_int()?;
                __packet_reader.finish()?;
                self.handle_axis_value120(axis, value120).await;
                Ok(())
            }
            10 => {
                let mut __packet_reader = __packet.read();
                let axis = __packet_reader.read_uint()?;
                let direction = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_axis_relative_direction(axis, direction).await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_pointer_v10_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_pointer_v10_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_set_cursor(
        &self,
        __object_id: crate::wayland::ObjectId,
        serial: u32,
        surface: ::std::option::Option<crate::wayland::ObjectId>,
        hotspot_x: i32,
        hotspot_y: i32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        __packet.push_uint(serial);
        __packet.push_object(surface);
        __packet.push_int(hotspot_x);
        __packet.push_int(hotspot_y);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_release(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_keyboard_v10_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_keymap(&self, format: u32, fd: ::std::os::fd::RawFd, size: u32);
    async fn handle_enter(
        &self,
        serial: u32,
        surface: ::std::option::Option<crate::wayland::ObjectId>,
        keys: ::std::vec::Vec<u8>,
    );
    async fn handle_leave(
        &self,
        serial: u32,
        surface: ::std::option::Option<crate::wayland::ObjectId>,
    );
    async fn handle_key(&self, serial: u32, time: u32, key: u32, state: u32);
    async fn handle_modifiers(
        &self,
        serial: u32,
        mods_depressed: u32,
        mods_latched: u32,
        mods_locked: u32,
        group: u32,
    );
    async fn handle_repeat_info(&self, rate: i32, delay: i32);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                let format = __packet_reader.read_uint()?;
                let fd = __packet_reader.read_fd()?;
                let size = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_keymap(format, fd, size).await;
                Ok(())
            }
            1 => {
                let mut __packet_reader = __packet.read();
                let serial = __packet_reader.read_uint()?;
                let surface = __packet_reader.read_object()?;
                let keys = __packet_reader.read_array()?;
                __packet_reader.finish()?;
                self.handle_enter(serial, surface, keys).await;
                Ok(())
            }
            2 => {
                let mut __packet_reader = __packet.read();
                let serial = __packet_reader.read_uint()?;
                let surface = __packet_reader.read_object()?;
                __packet_reader.finish()?;
                self.handle_leave(serial, surface).await;
                Ok(())
            }
            3 => {
                let mut __packet_reader = __packet.read();
                let serial = __packet_reader.read_uint()?;
                let time = __packet_reader.read_uint()?;
                let key = __packet_reader.read_uint()?;
                let state = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_key(serial, time, key, state).await;
                Ok(())
            }
            4 => {
                let mut __packet_reader = __packet.read();
                let serial = __packet_reader.read_uint()?;
                let mods_depressed = __packet_reader.read_uint()?;
                let mods_latched = __packet_reader.read_uint()?;
                let mods_locked = __packet_reader.read_uint()?;
                let group = __packet_reader.read_uint()?;
                __packet_reader.finish()?;
                self.handle_modifiers(serial, mods_depressed, mods_latched, mods_locked, group)
                    .await;
                Ok(())
            }
            5 => {
                let mut __packet_reader = __packet.read();
                let rate = __packet_reader.read_int()?;
                let delay = __packet_reader.read_int()?;
                __packet_reader.finish()?;
                self.handle_repeat_info(rate, delay).await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_keyboard_v10_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_keyboard_v10_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_release(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_touch_v10_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_down(
        &self,
        serial: u32,
        time: u32,
        surface: ::std::option::Option<crate::wayland::ObjectId>,
        id: i32,
        x: crate::wayland::Fixed,
        y: crate::wayland::Fixed,
    );
    async fn handle_up(&self, serial: u32, time: u32, id: i32);
    async fn handle_motion(
        &self,
        time: u32,
        id: i32,
        x: crate::wayland::Fixed,
        y: crate::wayland::Fixed,
    );
    async fn handle_frame(&self);
    async fn handle_cancel(&self);
    async fn handle_shape(
        &self,
        id: i32,
        major: crate::wayland::Fixed,
        minor: crate::wayland::Fixed,
    );
    async fn handle_orientation(&self, id: i32, orientation: crate::wayland::Fixed);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                let serial = __packet_reader.read_uint()?;
                let time = __packet_reader.read_uint()?;
                let surface = __packet_reader.read_object()?;
                let id = __packet_reader.read_int()?;
                let x = __packet_reader.read_fixed()?;
                let y = __packet_reader.read_fixed()?;
                __packet_reader.finish()?;
                self.handle_down(serial, time, surface, id, x, y).await;
                Ok(())
            }
            1 => {
                let mut __packet_reader = __packet.read();
                let serial = __packet_reader.read_uint()?;
                let time = __packet_reader.read_uint()?;
                let id = __packet_reader.read_int()?;
                __packet_reader.finish()?;
                self.handle_up(serial, time, id).await;
                Ok(())
            }
            2 => {
                let mut __packet_reader = __packet.read();
                let time = __packet_reader.read_uint()?;
                let id = __packet_reader.read_int()?;
                let x = __packet_reader.read_fixed()?;
                let y = __packet_reader.read_fixed()?;
                __packet_reader.finish()?;
                self.handle_motion(time, id, x, y).await;
                Ok(())
            }
            3 => {
                let mut __packet_reader = __packet.read();
                __packet_reader.finish()?;
                self.handle_frame().await;
                Ok(())
            }
            4 => {
                let mut __packet_reader = __packet.read();
                __packet_reader.finish()?;
                self.handle_cancel().await;
                Ok(())
            }
            5 => {
                let mut __packet_reader = __packet.read();
                let id = __packet_reader.read_int()?;
                let major = __packet_reader.read_fixed()?;
                let minor = __packet_reader.read_fixed()?;
                __packet_reader.finish()?;
                self.handle_shape(id, major, minor).await;
                Ok(())
            }
            6 => {
                let mut __packet_reader = __packet.read();
                let id = __packet_reader.read_int()?;
                let orientation = __packet_reader.read_fixed()?;
                __packet_reader.finish()?;
                self.handle_orientation(id, orientation).await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_touch_v10_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_touch_v10_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_release(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_output_v4_event_handler: crate::wayland::protocol::EventHandler {
    async fn handle_geometry(
        &self,
        x: i32,
        y: i32,
        physical_width: i32,
        physical_height: i32,
        subpixel: i32,
        make: ::std::string::String,
        model: ::std::string::String,
        transform: i32,
    );
    async fn handle_mode(&self, flags: u32, width: i32, height: i32, refresh: i32);
    async fn handle_done(&self);
    async fn handle_scale(&self, factor: i32);
    async fn handle_name(&self, name: ::std::string::String);
    async fn handle_description(&self, description: ::std::string::String);
    async fn unknown_event(&self, packet: crate::wayland::Packet) {
        let _ = packet;
    }
    async fn handle_event(
        &self,
        __packet: crate::wayland::Packet,
    ) -> ::std::result::Result<(), crate::wayland::Error> {
        match __packet.opcode() {
            0 => {
                let mut __packet_reader = __packet.read();
                let x = __packet_reader.read_int()?;
                let y = __packet_reader.read_int()?;
                let physical_width = __packet_reader.read_int()?;
                let physical_height = __packet_reader.read_int()?;
                let subpixel = __packet_reader.read_int()?;
                let make = __packet_reader.read_str()?;
                let model = __packet_reader.read_str()?;
                let transform = __packet_reader.read_int()?;
                __packet_reader.finish()?;
                self.handle_geometry(
                    x,
                    y,
                    physical_width,
                    physical_height,
                    subpixel,
                    make,
                    model,
                    transform,
                )
                .await;
                Ok(())
            }
            1 => {
                let mut __packet_reader = __packet.read();
                let flags = __packet_reader.read_uint()?;
                let width = __packet_reader.read_int()?;
                let height = __packet_reader.read_int()?;
                let refresh = __packet_reader.read_int()?;
                __packet_reader.finish()?;
                self.handle_mode(flags, width, height, refresh).await;
                Ok(())
            }
            2 => {
                let mut __packet_reader = __packet.read();
                __packet_reader.finish()?;
                self.handle_done().await;
                Ok(())
            }
            3 => {
                let mut __packet_reader = __packet.read();
                let factor = __packet_reader.read_int()?;
                __packet_reader.finish()?;
                self.handle_scale(factor).await;
                Ok(())
            }
            4 => {
                let mut __packet_reader = __packet.read();
                let name = __packet_reader.read_str()?;
                __packet_reader.finish()?;
                self.handle_name(name).await;
                Ok(())
            }
            5 => {
                let mut __packet_reader = __packet.read();
                let description = __packet_reader.read_str()?;
                __packet_reader.finish()?;
                self.handle_description(description).await;
                Ok(())
            }
            __other => {
                self.unknown_event(__packet).await;
                Ok(())
            }
        }
    }
}
#[allow(unused)]
pub struct wl_output_v4_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_output_v4_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_release(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub struct wl_region_v1_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_region_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_add(
        &self,
        __object_id: crate::wayland::ObjectId,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_int(width);
        __packet.push_int(height);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_subtract(
        &self,
        __object_id: crate::wayland::ObjectId,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 2);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_int(width);
        __packet.push_int(height);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub struct wl_subcompositor_v1_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_subcompositor_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_subsurface(
        &self,
        __object_id: crate::wayland::ObjectId,
        id: crate::wayland::NewObjectId,
        surface: ::std::option::Option<crate::wayland::ObjectId>,
        parent: ::std::option::Option<crate::wayland::ObjectId>,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(id);
        __packet.push_object(surface);
        __packet.push_object(parent);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub struct wl_subsurface_v1_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_subsurface_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_position(
        &self,
        __object_id: crate::wayland::ObjectId,
        x: i32,
        y: i32,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        __packet.push_int(x);
        __packet.push_int(y);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_place_above(
        &self,
        __object_id: crate::wayland::ObjectId,
        sibling: ::std::option::Option<crate::wayland::ObjectId>,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 2);
        __packet.push_object(sibling);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_place_below(
        &self,
        __object_id: crate::wayland::ObjectId,
        sibling: ::std::option::Option<crate::wayland::ObjectId>,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 3);
        __packet.push_object(sibling);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_sync(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 4);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_desync(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 5);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub struct wl_fixes_v1_request_proxy<'a> {
    connection: &'a crate::wayland::Connection,
}
#[allow(unused)]
impl<'a> wl_fixes_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::wayland::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(
        &self,
        __object_id: crate::wayland::ObjectId,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy_registry(
        &self,
        __object_id: crate::wayland::ObjectId,
        registry: ::std::option::Option<crate::wayland::ObjectId>,
    ) -> Result<(), crate::wayland::Error> {
        let mut __packet = crate::wayland::Packet::new(__object_id, 1);
        __packet.push_object(registry);
        self.connection.send_packet(&__packet).await
    }
}
