// This file has been autogenerated from a Wayland XML protocol definition.

#![allow(non_camel_case_types)]
#[allow(unused)]
pub struct ext_data_control_manager_v1_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> ext_data_control_manager_v1_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_create_data_source(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_data_device(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
        seat: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(id);
        __packet.push_object(seat);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        self.connection.send_packet(&__packet).await
    }
}
pub struct ext_data_control_manager_v1_v1_request_create_data_source_args {
    id: crate::NewObjectId,
}
impl ext_data_control_manager_v1_v1_request_create_data_source_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_manager_v1_v1_request_create_data_source_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        __reader.finish()?;
        Ok(Self { id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet>
    for ext_data_control_manager_v1_v1_request_create_data_source_args
{
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_manager_v1_v1_request_create_data_source_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_manager_v1_v1_request_create_data_source_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct ext_data_control_manager_v1_v1_request_get_data_device_args {
    id: crate::NewObjectId,
    seat: ::std::option::Option<crate::ObjectId>,
}
impl ext_data_control_manager_v1_v1_request_get_data_device_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_manager_v1_v1_request_get_data_device_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        let seat = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { id, seat })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        __packet.push_object(self.seat);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet>
    for ext_data_control_manager_v1_v1_request_get_data_device_args
{
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_manager_v1_v1_request_get_data_device_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_manager_v1_v1_request_get_data_device_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct ext_data_control_manager_v1_v1_request_destroy_args {}
impl ext_data_control_manager_v1_v1_request_destroy_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_manager_v1_v1_request_destroy_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet>
    for ext_data_control_manager_v1_v1_request_destroy_args
{
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_manager_v1_v1_request_destroy_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_manager_v1_v1_request_destroy_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait ext_data_control_device_v1_v1_event_handler: crate::protocol::EventHandler {
    fn handle_data_offer(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        id: crate::NewObjectId,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_selection(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        id: ::std::option::Option<crate::ObjectId>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_finished(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_primary_selection(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        id: ::std::option::Option<crate::ObjectId>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let id = __packet_reader.read_new_id_known_interface()?;
                    __packet_reader.finish()?;
                    self.handle_data_offer(__connection, __packet, id).await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let id = __packet_reader.read_object()?;
                    __packet_reader.finish()?;
                    self.handle_selection(__connection, __packet, id).await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_finished(__connection, __packet).await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    let id = __packet_reader.read_object()?;
                    __packet_reader.finish()?;
                    self.handle_primary_selection(__connection, __packet, id)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct ext_data_control_device_v1_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> ext_data_control_device_v1_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_set_selection(
        &self,
        __object_id: crate::ObjectId,
        source: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_object(source);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_primary_selection(
        &self,
        __object_id: crate::ObjectId,
        source: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_object(source);
        self.connection.send_packet(&__packet).await
    }
}
pub struct ext_data_control_device_v1_v1_request_set_selection_args {
    source: ::std::option::Option<crate::ObjectId>,
}
impl ext_data_control_device_v1_v1_request_set_selection_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_device_v1_v1_request_set_selection_args, crate::Error> {
        let mut __reader = __value.read();
        let source = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { source })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.source);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet>
    for ext_data_control_device_v1_v1_request_set_selection_args
{
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_device_v1_v1_request_set_selection_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_device_v1_v1_request_set_selection_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct ext_data_control_device_v1_v1_request_destroy_args {}
impl ext_data_control_device_v1_v1_request_destroy_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_device_v1_v1_request_destroy_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for ext_data_control_device_v1_v1_request_destroy_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_device_v1_v1_request_destroy_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_device_v1_v1_request_destroy_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct ext_data_control_device_v1_v1_request_set_primary_selection_args {
    source: ::std::option::Option<crate::ObjectId>,
}
impl ext_data_control_device_v1_v1_request_set_primary_selection_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_device_v1_v1_request_set_primary_selection_args, crate::Error>
    {
        let mut __reader = __value.read();
        let source = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { source })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.source);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet>
    for ext_data_control_device_v1_v1_request_set_primary_selection_args
{
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_device_v1_v1_request_set_primary_selection_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_device_v1_v1_request_set_primary_selection_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct ext_data_control_device_v1_v1_event_data_offer_args {
    id: crate::NewObjectId,
}
impl ext_data_control_device_v1_v1_event_data_offer_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_device_v1_v1_event_data_offer_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        __reader.finish()?;
        Ok(Self { id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet>
    for ext_data_control_device_v1_v1_event_data_offer_args
{
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_device_v1_v1_event_data_offer_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_device_v1_v1_event_data_offer_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct ext_data_control_device_v1_v1_event_selection_args {
    id: ::std::option::Option<crate::ObjectId>,
}
impl ext_data_control_device_v1_v1_event_selection_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_device_v1_v1_event_selection_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for ext_data_control_device_v1_v1_event_selection_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_device_v1_v1_event_selection_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_device_v1_v1_event_selection_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct ext_data_control_device_v1_v1_event_finished_args {}
impl ext_data_control_device_v1_v1_event_finished_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_device_v1_v1_event_finished_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for ext_data_control_device_v1_v1_event_finished_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_device_v1_v1_event_finished_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_device_v1_v1_event_finished_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct ext_data_control_device_v1_v1_event_primary_selection_args {
    id: ::std::option::Option<crate::ObjectId>,
}
impl ext_data_control_device_v1_v1_event_primary_selection_args {
    pub const OPCODE: u16 = 3;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_device_v1_v1_event_primary_selection_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet>
    for ext_data_control_device_v1_v1_event_primary_selection_args
{
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_device_v1_v1_event_primary_selection_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_device_v1_v1_event_primary_selection_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait ext_data_control_source_v1_v1_event_handler: crate::protocol::EventHandler {
    fn handle_send(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        mime_type: ::std::string::String,
        fd: ::std::os::fd::RawFd,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_cancelled(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let mime_type = __packet_reader.read_str()?;
                    let fd = __packet_reader.read_fd()?;
                    __packet_reader.finish()?;
                    self.handle_send(__connection, __packet, mime_type, fd)
                        .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_cancelled(__connection, __packet).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct ext_data_control_source_v1_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> ext_data_control_source_v1_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_offer(
        &self,
        __object_id: crate::ObjectId,
        mime_type: &str,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_str(&mime_type);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
}
pub struct ext_data_control_source_v1_v1_request_offer_args {
    mime_type: ::std::string::String,
}
impl ext_data_control_source_v1_v1_request_offer_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_source_v1_v1_request_offer_args, crate::Error> {
        let mut __reader = __value.read();
        let mime_type = __reader.read_str()?;
        __reader.finish()?;
        Ok(Self { mime_type })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_str(&self.mime_type);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for ext_data_control_source_v1_v1_request_offer_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_source_v1_v1_request_offer_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_source_v1_v1_request_offer_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct ext_data_control_source_v1_v1_request_destroy_args {}
impl ext_data_control_source_v1_v1_request_destroy_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_source_v1_v1_request_destroy_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for ext_data_control_source_v1_v1_request_destroy_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_source_v1_v1_request_destroy_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_source_v1_v1_request_destroy_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct ext_data_control_source_v1_v1_event_send_args {
    mime_type: ::std::string::String,
    fd: ::std::os::fd::RawFd,
}
impl ext_data_control_source_v1_v1_event_send_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_source_v1_v1_event_send_args, crate::Error> {
        let mut __reader = __value.read();
        let mime_type = __reader.read_str()?;
        let fd = __reader.read_fd()?;
        __reader.finish()?;
        Ok(Self { mime_type, fd })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_str(&self.mime_type);
        __packet.push_fd(self.fd);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for ext_data_control_source_v1_v1_event_send_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_source_v1_v1_event_send_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_source_v1_v1_event_send_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct ext_data_control_source_v1_v1_event_cancelled_args {}
impl ext_data_control_source_v1_v1_event_cancelled_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_source_v1_v1_event_cancelled_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for ext_data_control_source_v1_v1_event_cancelled_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_source_v1_v1_event_cancelled_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_source_v1_v1_event_cancelled_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait ext_data_control_offer_v1_v1_event_handler: crate::protocol::EventHandler {
    fn handle_offer(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        mime_type: ::std::string::String,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let mime_type = __packet_reader.read_str()?;
                    __packet_reader.finish()?;
                    self.handle_offer(__connection, __packet, mime_type).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct ext_data_control_offer_v1_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> ext_data_control_offer_v1_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_receive(
        &self,
        __object_id: crate::ObjectId,
        mime_type: &str,
        fd: ::std::os::fd::RawFd,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_str(&mime_type);
        __packet.push_fd(fd);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
}
pub struct ext_data_control_offer_v1_v1_request_receive_args {
    mime_type: ::std::string::String,
    fd: ::std::os::fd::RawFd,
}
impl ext_data_control_offer_v1_v1_request_receive_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_offer_v1_v1_request_receive_args, crate::Error> {
        let mut __reader = __value.read();
        let mime_type = __reader.read_str()?;
        let fd = __reader.read_fd()?;
        __reader.finish()?;
        Ok(Self { mime_type, fd })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_str(&self.mime_type);
        __packet.push_fd(self.fd);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for ext_data_control_offer_v1_v1_request_receive_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_offer_v1_v1_request_receive_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_offer_v1_v1_request_receive_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct ext_data_control_offer_v1_v1_request_destroy_args {}
impl ext_data_control_offer_v1_v1_request_destroy_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_offer_v1_v1_request_destroy_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for ext_data_control_offer_v1_v1_request_destroy_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_offer_v1_v1_request_destroy_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_offer_v1_v1_request_destroy_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct ext_data_control_offer_v1_v1_event_offer_args {
    mime_type: ::std::string::String,
}
impl ext_data_control_offer_v1_v1_event_offer_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<ext_data_control_offer_v1_v1_event_offer_args, crate::Error> {
        let mut __reader = __value.read();
        let mime_type = __reader.read_str()?;
        __reader.finish()?;
        Ok(Self { mime_type })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_str(&self.mime_type);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for ext_data_control_offer_v1_v1_event_offer_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        ext_data_control_offer_v1_v1_event_offer_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            ext_data_control_offer_v1_v1_event_offer_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
