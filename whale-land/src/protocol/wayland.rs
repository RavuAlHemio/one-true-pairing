// This file has been autogenerated from a Wayland XML protocol definition.

#![allow(non_camel_case_types)]
#[allow(unused)]
pub trait wl_display_v1_event_handler: crate::protocol::EventHandler {
    fn handle_error(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        object_id: ::std::option::Option<crate::ObjectId>,
        code: u32,
        message: ::std::string::String,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_delete_id(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        id: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let object_id = __packet_reader.read_object()?;
                    let code = __packet_reader.read_uint()?;
                    let message = __packet_reader.read_str()?;
                    __packet_reader.finish()?;
                    self.handle_error(__connection, __packet, object_id, code, message)
                        .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let id = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_delete_id(__connection, __packet, id).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_display_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_display_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_sync(
        &self,
        __object_id: crate::ObjectId,
        callback: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(callback);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_registry(
        &self,
        __object_id: crate::ObjectId,
        registry: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(registry);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_registry_v1_event_handler: crate::protocol::EventHandler {
    fn handle_global(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        name: u32,
        interface: ::std::string::String,
        version: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_global_remove(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        name: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let name = __packet_reader.read_uint()?;
                    let interface = __packet_reader.read_str()?;
                    let version = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_global(__connection, __packet, name, interface, version)
                        .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let name = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_global_remove(__connection, __packet, name)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_registry_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_registry_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_bind(
        &self,
        __object_id: crate::ObjectId,
        name: u32,
        id: crate::NewObject,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_uint(name);
        __packet.push_new_id_unknown_interface(id);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_callback_v1_event_handler: crate::protocol::EventHandler {
    fn handle_done(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        callback_data: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let callback_data = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_done(__connection, __packet, callback_data)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_compositor_v6_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_compositor_v6_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_create_surface(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_create_region(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub struct wl_shm_pool_v2_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_shm_pool_v2_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_create_buffer(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
        offset: i32,
        width: i32,
        height: i32,
        stride: i32,
        format: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        __packet.push_int(offset);
        __packet.push_int(width);
        __packet.push_int(height);
        __packet.push_int(stride);
        __packet.push_uint(format);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_resize(
        &self,
        __object_id: crate::ObjectId,
        size: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_int(size);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_shm_v2_event_handler: crate::protocol::EventHandler {
    fn handle_format(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        format: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let format = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_format(__connection, __packet, format).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_shm_v2_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_shm_v2_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_create_pool(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
        fd: ::std::os::fd::RawFd,
        size: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        __packet.push_fd(fd);
        __packet.push_int(size);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_release(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_buffer_v1_event_handler: crate::protocol::EventHandler {
    fn handle_release(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_release(__connection, __packet).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_buffer_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_buffer_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_data_offer_v3_event_handler: crate::protocol::EventHandler {
    fn handle_offer(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        mime_type: ::std::string::String,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_source_actions(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        source_actions: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_action(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        dnd_action: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let mime_type = __packet_reader.read_str()?;
                    __packet_reader.finish()?;
                    self.handle_offer(__connection, __packet, mime_type).await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let source_actions = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_source_actions(__connection, __packet, source_actions)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    let dnd_action = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_action(__connection, __packet, dnd_action).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_data_offer_v3_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_data_offer_v3_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_accept(
        &self,
        __object_id: crate::ObjectId,
        serial: u32,
        mime_type: &str,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_uint(serial);
        __packet.push_str(mime_type);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_receive(
        &self,
        __object_id: crate::ObjectId,
        mime_type: &str,
        fd: ::std::os::fd::RawFd,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_str(mime_type);
        __packet.push_fd(fd);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_finish(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 3);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_actions(
        &self,
        __object_id: crate::ObjectId,
        dnd_actions: u32,
        preferred_action: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 4);
        __packet.push_uint(dnd_actions);
        __packet.push_uint(preferred_action);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_data_source_v3_event_handler: crate::protocol::EventHandler {
    fn handle_target(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        mime_type: ::std::string::String,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_send(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        mime_type: ::std::string::String,
        fd: ::std::os::fd::RawFd,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_cancelled(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_dnd_drop_performed(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_dnd_finished(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_action(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        dnd_action: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let mime_type = __packet_reader.read_str()?;
                    __packet_reader.finish()?;
                    self.handle_target(__connection, __packet, mime_type).await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let mime_type = __packet_reader.read_str()?;
                    let fd = __packet_reader.read_fd()?;
                    __packet_reader.finish()?;
                    self.handle_send(__connection, __packet, mime_type, fd)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_cancelled(__connection, __packet).await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_dnd_drop_performed(__connection, __packet).await;
                    Ok(())
                }
                4 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_dnd_finished(__connection, __packet).await;
                    Ok(())
                }
                5 => {
                    let mut __packet_reader = __packet.read();
                    let dnd_action = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_action(__connection, __packet, dnd_action).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_data_source_v3_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_data_source_v3_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_offer(
        &self,
        __object_id: crate::ObjectId,
        mime_type: &str,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_str(mime_type);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_actions(
        &self,
        __object_id: crate::ObjectId,
        dnd_actions: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_uint(dnd_actions);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_data_device_v3_event_handler: crate::protocol::EventHandler {
    fn handle_data_offer(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        id: crate::NewObjectId,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_enter(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        surface: ::std::option::Option<crate::ObjectId>,
        x: crate::Fixed,
        y: crate::Fixed,
        id: ::std::option::Option<crate::ObjectId>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_leave(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_motion(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        time: u32,
        x: crate::Fixed,
        y: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_drop(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_selection(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        id: ::std::option::Option<crate::ObjectId>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let __new_id_uint_id = __packet_reader.read_uint()?;
                    let id = crate::NewObjectId(
                        crate::ObjectId::new(__new_id_uint_id).ok_or(crate::Error::ZeroObjectId)?,
                    );
                    __packet_reader.finish()?;
                    self.handle_data_offer(__connection, __packet, id).await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let surface = __packet_reader.read_object()?;
                    let x = __packet_reader.read_fixed()?;
                    let y = __packet_reader.read_fixed()?;
                    let id = __packet_reader.read_object()?;
                    __packet_reader.finish()?;
                    self.handle_enter(__connection, __packet, serial, surface, x, y, id)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_leave(__connection, __packet).await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    let time = __packet_reader.read_uint()?;
                    let x = __packet_reader.read_fixed()?;
                    let y = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_motion(__connection, __packet, time, x, y).await;
                    Ok(())
                }
                4 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_drop(__connection, __packet).await;
                    Ok(())
                }
                5 => {
                    let mut __packet_reader = __packet.read();
                    let id = __packet_reader.read_object()?;
                    __packet_reader.finish()?;
                    self.handle_selection(__connection, __packet, id).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_data_device_v3_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_data_device_v3_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_start_drag(
        &self,
        __object_id: crate::ObjectId,
        source: ::std::option::Option<crate::ObjectId>,
        origin: ::std::option::Option<crate::ObjectId>,
        icon: ::std::option::Option<crate::ObjectId>,
        serial: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_object(source);
        __packet.push_object(origin);
        __packet.push_object(icon);
        __packet.push_uint(serial);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_selection(
        &self,
        __object_id: crate::ObjectId,
        source: ::std::option::Option<crate::ObjectId>,
        serial: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_object(source);
        __packet.push_uint(serial);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_release(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub struct wl_data_device_manager_v3_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_data_device_manager_v3_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_create_data_source(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_data_device(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
        seat: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(id);
        __packet.push_object(seat);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub struct wl_shell_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_shell_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_get_shell_surface(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
        surface: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        __packet.push_object(surface);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_shell_surface_v1_event_handler: crate::protocol::EventHandler {
    fn handle_ping(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_configure(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        edges: u32,
        width: i32,
        height: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_popup_done(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_ping(__connection, __packet, serial).await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let edges = __packet_reader.read_uint()?;
                    let width = __packet_reader.read_int()?;
                    let height = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_configure(__connection, __packet, edges, width, height)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_popup_done(__connection, __packet).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_shell_surface_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_shell_surface_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_pong(
        &self,
        __object_id: crate::ObjectId,
        serial: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_uint(serial);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_move(
        &self,
        __object_id: crate::ObjectId,
        seat: ::std::option::Option<crate::ObjectId>,
        serial: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_object(seat);
        __packet.push_uint(serial);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_resize(
        &self,
        __object_id: crate::ObjectId,
        seat: ::std::option::Option<crate::ObjectId>,
        serial: u32,
        edges: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_object(seat);
        __packet.push_uint(serial);
        __packet.push_uint(edges);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_toplevel(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 3);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_transient(
        &self,
        __object_id: crate::ObjectId,
        parent: ::std::option::Option<crate::ObjectId>,
        x: i32,
        y: i32,
        flags: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 4);
        __packet.push_object(parent);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_uint(flags);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_fullscreen(
        &self,
        __object_id: crate::ObjectId,
        method: u32,
        framerate: u32,
        output: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 5);
        __packet.push_uint(method);
        __packet.push_uint(framerate);
        __packet.push_object(output);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_popup(
        &self,
        __object_id: crate::ObjectId,
        seat: ::std::option::Option<crate::ObjectId>,
        serial: u32,
        parent: ::std::option::Option<crate::ObjectId>,
        x: i32,
        y: i32,
        flags: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 6);
        __packet.push_object(seat);
        __packet.push_uint(serial);
        __packet.push_object(parent);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_uint(flags);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_maximized(
        &self,
        __object_id: crate::ObjectId,
        output: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 7);
        __packet.push_object(output);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_title(
        &self,
        __object_id: crate::ObjectId,
        title: &str,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 8);
        __packet.push_str(title);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_class(
        &self,
        __object_id: crate::ObjectId,
        class_: &str,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 9);
        __packet.push_str(class_);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_surface_v6_event_handler: crate::protocol::EventHandler {
    fn handle_enter(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        output: ::std::option::Option<crate::ObjectId>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_leave(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        output: ::std::option::Option<crate::ObjectId>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_preferred_buffer_scale(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        factor: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_preferred_buffer_transform(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        transform: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let output = __packet_reader.read_object()?;
                    __packet_reader.finish()?;
                    self.handle_enter(__connection, __packet, output).await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let output = __packet_reader.read_object()?;
                    __packet_reader.finish()?;
                    self.handle_leave(__connection, __packet, output).await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    let factor = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_preferred_buffer_scale(__connection, __packet, factor)
                        .await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    let transform = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_preferred_buffer_transform(__connection, __packet, transform)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_surface_v6_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_surface_v6_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_attach(
        &self,
        __object_id: crate::ObjectId,
        buffer: ::std::option::Option<crate::ObjectId>,
        x: i32,
        y: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_object(buffer);
        __packet.push_int(x);
        __packet.push_int(y);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_damage(
        &self,
        __object_id: crate::ObjectId,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_int(width);
        __packet.push_int(height);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_frame(
        &self,
        __object_id: crate::ObjectId,
        callback: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 3);
        __packet.push_new_id_known_interface(callback);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_opaque_region(
        &self,
        __object_id: crate::ObjectId,
        region: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 4);
        __packet.push_object(region);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_input_region(
        &self,
        __object_id: crate::ObjectId,
        region: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 5);
        __packet.push_object(region);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_commit(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 6);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_buffer_transform(
        &self,
        __object_id: crate::ObjectId,
        transform: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 7);
        __packet.push_int(transform);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_buffer_scale(
        &self,
        __object_id: crate::ObjectId,
        scale: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 8);
        __packet.push_int(scale);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_damage_buffer(
        &self,
        __object_id: crate::ObjectId,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 9);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_int(width);
        __packet.push_int(height);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_offset(
        &self,
        __object_id: crate::ObjectId,
        x: i32,
        y: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 10);
        __packet.push_int(x);
        __packet.push_int(y);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_seat_v10_event_handler: crate::protocol::EventHandler {
    fn handle_capabilities(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        capabilities: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_name(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        name: ::std::string::String,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let capabilities = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_capabilities(__connection, __packet, capabilities)
                        .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let name = __packet_reader.read_str()?;
                    __packet_reader.finish()?;
                    self.handle_name(__connection, __packet, name).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_seat_v10_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_seat_v10_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_get_pointer(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_keyboard(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_touch(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_release(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 3);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_pointer_v10_event_handler: crate::protocol::EventHandler {
    fn handle_enter(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        surface: ::std::option::Option<crate::ObjectId>,
        surface_x: crate::Fixed,
        surface_y: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_leave(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        surface: ::std::option::Option<crate::ObjectId>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_motion(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        time: u32,
        surface_x: crate::Fixed,
        surface_y: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_button(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        time: u32,
        button: u32,
        state: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_axis(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        time: u32,
        axis: u32,
        value: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_frame(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_axis_source(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        axis_source: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_axis_stop(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        time: u32,
        axis: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_axis_discrete(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        axis: u32,
        discrete: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_axis_value120(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        axis: u32,
        value120: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_axis_relative_direction(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        axis: u32,
        direction: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let surface = __packet_reader.read_object()?;
                    let surface_x = __packet_reader.read_fixed()?;
                    let surface_y = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_enter(
                        __connection,
                        __packet,
                        serial,
                        surface,
                        surface_x,
                        surface_y,
                    )
                    .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let surface = __packet_reader.read_object()?;
                    __packet_reader.finish()?;
                    self.handle_leave(__connection, __packet, serial, surface)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    let time = __packet_reader.read_uint()?;
                    let surface_x = __packet_reader.read_fixed()?;
                    let surface_y = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_motion(__connection, __packet, time, surface_x, surface_y)
                        .await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let time = __packet_reader.read_uint()?;
                    let button = __packet_reader.read_uint()?;
                    let state = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_button(__connection, __packet, serial, time, button, state)
                        .await;
                    Ok(())
                }
                4 => {
                    let mut __packet_reader = __packet.read();
                    let time = __packet_reader.read_uint()?;
                    let axis = __packet_reader.read_uint()?;
                    let value = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_axis(__connection, __packet, time, axis, value)
                        .await;
                    Ok(())
                }
                5 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_frame(__connection, __packet).await;
                    Ok(())
                }
                6 => {
                    let mut __packet_reader = __packet.read();
                    let axis_source = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_axis_source(__connection, __packet, axis_source)
                        .await;
                    Ok(())
                }
                7 => {
                    let mut __packet_reader = __packet.read();
                    let time = __packet_reader.read_uint()?;
                    let axis = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_axis_stop(__connection, __packet, time, axis)
                        .await;
                    Ok(())
                }
                8 => {
                    let mut __packet_reader = __packet.read();
                    let axis = __packet_reader.read_uint()?;
                    let discrete = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_axis_discrete(__connection, __packet, axis, discrete)
                        .await;
                    Ok(())
                }
                9 => {
                    let mut __packet_reader = __packet.read();
                    let axis = __packet_reader.read_uint()?;
                    let value120 = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_axis_value120(__connection, __packet, axis, value120)
                        .await;
                    Ok(())
                }
                10 => {
                    let mut __packet_reader = __packet.read();
                    let axis = __packet_reader.read_uint()?;
                    let direction = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_axis_relative_direction(__connection, __packet, axis, direction)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_pointer_v10_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_pointer_v10_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_set_cursor(
        &self,
        __object_id: crate::ObjectId,
        serial: u32,
        surface: ::std::option::Option<crate::ObjectId>,
        hotspot_x: i32,
        hotspot_y: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_uint(serial);
        __packet.push_object(surface);
        __packet.push_int(hotspot_x);
        __packet.push_int(hotspot_y);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_release(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_keyboard_v10_event_handler: crate::protocol::EventHandler {
    fn handle_keymap(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        format: u32,
        fd: ::std::os::fd::RawFd,
        size: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_enter(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        surface: ::std::option::Option<crate::ObjectId>,
        keys: ::std::vec::Vec<u8>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_leave(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        surface: ::std::option::Option<crate::ObjectId>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_key(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        time: u32,
        key: u32,
        state: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_modifiers(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        mods_depressed: u32,
        mods_latched: u32,
        mods_locked: u32,
        group: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_repeat_info(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        rate: i32,
        delay: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let format = __packet_reader.read_uint()?;
                    let fd = __packet_reader.read_fd()?;
                    let size = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_keymap(__connection, __packet, format, fd, size)
                        .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let surface = __packet_reader.read_object()?;
                    let keys = __packet_reader.read_array()?;
                    __packet_reader.finish()?;
                    self.handle_enter(__connection, __packet, serial, surface, keys)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let surface = __packet_reader.read_object()?;
                    __packet_reader.finish()?;
                    self.handle_leave(__connection, __packet, serial, surface)
                        .await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let time = __packet_reader.read_uint()?;
                    let key = __packet_reader.read_uint()?;
                    let state = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_key(__connection, __packet, serial, time, key, state)
                        .await;
                    Ok(())
                }
                4 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let mods_depressed = __packet_reader.read_uint()?;
                    let mods_latched = __packet_reader.read_uint()?;
                    let mods_locked = __packet_reader.read_uint()?;
                    let group = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_modifiers(
                        __connection,
                        __packet,
                        serial,
                        mods_depressed,
                        mods_latched,
                        mods_locked,
                        group,
                    )
                    .await;
                    Ok(())
                }
                5 => {
                    let mut __packet_reader = __packet.read();
                    let rate = __packet_reader.read_int()?;
                    let delay = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_repeat_info(__connection, __packet, rate, delay)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_keyboard_v10_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_keyboard_v10_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_release(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_touch_v10_event_handler: crate::protocol::EventHandler {
    fn handle_down(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        time: u32,
        surface: ::std::option::Option<crate::ObjectId>,
        id: i32,
        x: crate::Fixed,
        y: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_up(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        time: u32,
        id: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_motion(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        time: u32,
        id: i32,
        x: crate::Fixed,
        y: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_frame(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_cancel(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_shape(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        id: i32,
        major: crate::Fixed,
        minor: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_orientation(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        id: i32,
        orientation: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let time = __packet_reader.read_uint()?;
                    let surface = __packet_reader.read_object()?;
                    let id = __packet_reader.read_int()?;
                    let x = __packet_reader.read_fixed()?;
                    let y = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_down(__connection, __packet, serial, time, surface, id, x, y)
                        .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let time = __packet_reader.read_uint()?;
                    let id = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_up(__connection, __packet, serial, time, id)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    let time = __packet_reader.read_uint()?;
                    let id = __packet_reader.read_int()?;
                    let x = __packet_reader.read_fixed()?;
                    let y = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_motion(__connection, __packet, time, id, x, y)
                        .await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_frame(__connection, __packet).await;
                    Ok(())
                }
                4 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_cancel(__connection, __packet).await;
                    Ok(())
                }
                5 => {
                    let mut __packet_reader = __packet.read();
                    let id = __packet_reader.read_int()?;
                    let major = __packet_reader.read_fixed()?;
                    let minor = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_shape(__connection, __packet, id, major, minor)
                        .await;
                    Ok(())
                }
                6 => {
                    let mut __packet_reader = __packet.read();
                    let id = __packet_reader.read_int()?;
                    let orientation = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_orientation(__connection, __packet, id, orientation)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_touch_v10_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_touch_v10_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_release(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub trait wl_output_v4_event_handler: crate::protocol::EventHandler {
    fn handle_geometry(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        x: i32,
        y: i32,
        physical_width: i32,
        physical_height: i32,
        subpixel: i32,
        make: ::std::string::String,
        model: ::std::string::String,
        transform: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_mode(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        flags: u32,
        width: i32,
        height: i32,
        refresh: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_done(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_scale(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        factor: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_name(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        name: ::std::string::String,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_description(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        description: ::std::string::String,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let x = __packet_reader.read_int()?;
                    let y = __packet_reader.read_int()?;
                    let physical_width = __packet_reader.read_int()?;
                    let physical_height = __packet_reader.read_int()?;
                    let subpixel = __packet_reader.read_int()?;
                    let make = __packet_reader.read_str()?;
                    let model = __packet_reader.read_str()?;
                    let transform = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_geometry(
                        __connection,
                        __packet,
                        x,
                        y,
                        physical_width,
                        physical_height,
                        subpixel,
                        make,
                        model,
                        transform,
                    )
                    .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let flags = __packet_reader.read_uint()?;
                    let width = __packet_reader.read_int()?;
                    let height = __packet_reader.read_int()?;
                    let refresh = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_mode(__connection, __packet, flags, width, height, refresh)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_done(__connection, __packet).await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    let factor = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_scale(__connection, __packet, factor).await;
                    Ok(())
                }
                4 => {
                    let mut __packet_reader = __packet.read();
                    let name = __packet_reader.read_str()?;
                    __packet_reader.finish()?;
                    self.handle_name(__connection, __packet, name).await;
                    Ok(())
                }
                5 => {
                    let mut __packet_reader = __packet.read();
                    let description = __packet_reader.read_str()?;
                    __packet_reader.finish()?;
                    self.handle_description(__connection, __packet, description)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_output_v4_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_output_v4_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_release(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub struct wl_region_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_region_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_add(
        &self,
        __object_id: crate::ObjectId,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_int(width);
        __packet.push_int(height);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_subtract(
        &self,
        __object_id: crate::ObjectId,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_int(width);
        __packet.push_int(height);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub struct wl_subcompositor_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_subcompositor_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_subsurface(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
        surface: ::std::option::Option<crate::ObjectId>,
        parent: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(id);
        __packet.push_object(surface);
        __packet.push_object(parent);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub struct wl_subsurface_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_subsurface_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_position(
        &self,
        __object_id: crate::ObjectId,
        x: i32,
        y: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_int(x);
        __packet.push_int(y);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_place_above(
        &self,
        __object_id: crate::ObjectId,
        sibling: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_object(sibling);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_place_below(
        &self,
        __object_id: crate::ObjectId,
        sibling: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 3);
        __packet.push_object(sibling);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_sync(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 4);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_desync(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 5);
        self.connection.send_packet(&__packet).await
    }
}
#[allow(unused)]
pub struct wl_fixes_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_fixes_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy_registry(
        &self,
        __object_id: crate::ObjectId,
        registry: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_object(registry);
        self.connection.send_packet(&__packet).await
    }
}
