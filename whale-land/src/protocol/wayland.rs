// This file has been autogenerated from a Wayland XML protocol definition.

#![allow(non_camel_case_types)]
#[allow(unused)]
pub trait wl_display_v1_event_handler: crate::protocol::EventHandler {
    fn handle_error(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        object_id: ::std::option::Option<crate::ObjectId>,
        code: u32,
        message: ::std::string::String,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_delete_id(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        id: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let object_id = __packet_reader.read_object()?;
                    let code = __packet_reader.read_uint()?;
                    let message = __packet_reader.read_str()?;
                    __packet_reader.finish()?;
                    self.handle_error(__connection, __packet, object_id, code, message)
                        .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let id = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_delete_id(__connection, __packet, id).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_display_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_display_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_sync(
        &self,
        __object_id: crate::ObjectId,
        callback: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(callback);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_registry(
        &self,
        __object_id: crate::ObjectId,
        registry: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(registry);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_display_v1_request_sync_args {
    callback: crate::NewObjectId,
}
impl wl_display_v1_request_sync_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_display_v1_request_sync_args, crate::Error> {
        let mut __reader = __value.read();
        let callback = __reader.read_new_id_known_interface()?;
        __reader.finish()?;
        Ok(Self { callback })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.callback);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_display_v1_request_sync_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_display_v1_request_sync_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_display_v1_request_sync_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_display_v1_request_get_registry_args {
    registry: crate::NewObjectId,
}
impl wl_display_v1_request_get_registry_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_display_v1_request_get_registry_args, crate::Error> {
        let mut __reader = __value.read();
        let registry = __reader.read_new_id_known_interface()?;
        __reader.finish()?;
        Ok(Self { registry })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.registry);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_display_v1_request_get_registry_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_display_v1_request_get_registry_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_display_v1_request_get_registry_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_display_v1_event_error_args {
    object_id: ::std::option::Option<crate::ObjectId>,
    code: u32,
    message: ::std::string::String,
}
impl wl_display_v1_event_error_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_display_v1_event_error_args, crate::Error> {
        let mut __reader = __value.read();
        let object_id = __reader.read_object()?;
        let code = __reader.read_uint()?;
        let message = __reader.read_str()?;
        __reader.finish()?;
        Ok(Self {
            object_id,
            code,
            message,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.object_id);
        __packet.push_uint(self.code);
        __packet.push_str(&self.message);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_display_v1_event_error_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_display_v1_event_error_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_display_v1_event_error_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_display_v1_event_delete_id_args {
    id: u32,
}
impl wl_display_v1_event_delete_id_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_display_v1_event_delete_id_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_display_v1_event_delete_id_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_display_v1_event_delete_id_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_display_v1_event_delete_id_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait wl_registry_v1_event_handler: crate::protocol::EventHandler {
    fn handle_global(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        name: u32,
        interface: ::std::string::String,
        version: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_global_remove(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        name: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let name = __packet_reader.read_uint()?;
                    let interface = __packet_reader.read_str()?;
                    let version = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_global(__connection, __packet, name, interface, version)
                        .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let name = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_global_remove(__connection, __packet, name)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_registry_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_registry_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_bind(
        &self,
        __object_id: crate::ObjectId,
        name: u32,
        id: crate::NewObject,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_uint(name);
        __packet.push_new_id_unknown_interface(&id);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_registry_v1_request_bind_args {
    name: u32,
    id: crate::NewObject,
}
impl wl_registry_v1_request_bind_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_registry_v1_request_bind_args, crate::Error> {
        let mut __reader = __value.read();
        let name = __reader.read_uint()?;
        let id = __reader.read_new_id_unknown_interface()?;
        __reader.finish()?;
        Ok(Self { name, id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.name);
        __packet.push_new_id_unknown_interface(&self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_registry_v1_request_bind_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_registry_v1_request_bind_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_registry_v1_request_bind_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_registry_v1_event_global_args {
    name: u32,
    interface: ::std::string::String,
    version: u32,
}
impl wl_registry_v1_event_global_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_registry_v1_event_global_args, crate::Error> {
        let mut __reader = __value.read();
        let name = __reader.read_uint()?;
        let interface = __reader.read_str()?;
        let version = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self {
            name,
            interface,
            version,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.name);
        __packet.push_str(&self.interface);
        __packet.push_uint(self.version);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_registry_v1_event_global_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_registry_v1_event_global_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_registry_v1_event_global_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_registry_v1_event_global_remove_args {
    name: u32,
}
impl wl_registry_v1_event_global_remove_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_registry_v1_event_global_remove_args, crate::Error> {
        let mut __reader = __value.read();
        let name = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { name })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.name);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_registry_v1_event_global_remove_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_registry_v1_event_global_remove_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_registry_v1_event_global_remove_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait wl_callback_v1_event_handler: crate::protocol::EventHandler {
    fn handle_done(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        callback_data: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let callback_data = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_done(__connection, __packet, callback_data)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
pub struct wl_callback_v1_event_done_args {
    callback_data: u32,
}
impl wl_callback_v1_event_done_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_callback_v1_event_done_args, crate::Error> {
        let mut __reader = __value.read();
        let callback_data = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { callback_data })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.callback_data);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_callback_v1_event_done_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_callback_v1_event_done_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_callback_v1_event_done_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub struct wl_compositor_v6_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_compositor_v6_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_create_surface(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_create_region(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_compositor_v6_request_create_surface_args {
    id: crate::NewObjectId,
}
impl wl_compositor_v6_request_create_surface_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_compositor_v6_request_create_surface_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        __reader.finish()?;
        Ok(Self { id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_compositor_v6_request_create_surface_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_compositor_v6_request_create_surface_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_compositor_v6_request_create_surface_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_compositor_v6_request_create_region_args {
    id: crate::NewObjectId,
}
impl wl_compositor_v6_request_create_region_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_compositor_v6_request_create_region_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        __reader.finish()?;
        Ok(Self { id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_compositor_v6_request_create_region_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_compositor_v6_request_create_region_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_compositor_v6_request_create_region_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub struct wl_shm_pool_v2_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_shm_pool_v2_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_create_buffer(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
        offset: i32,
        width: i32,
        height: i32,
        stride: i32,
        format: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        __packet.push_int(offset);
        __packet.push_int(width);
        __packet.push_int(height);
        __packet.push_int(stride);
        __packet.push_uint(format);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_resize(
        &self,
        __object_id: crate::ObjectId,
        size: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_int(size);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_shm_pool_v2_request_create_buffer_args {
    id: crate::NewObjectId,
    offset: i32,
    width: i32,
    height: i32,
    stride: i32,
    format: u32,
}
impl wl_shm_pool_v2_request_create_buffer_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shm_pool_v2_request_create_buffer_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        let offset = __reader.read_int()?;
        let width = __reader.read_int()?;
        let height = __reader.read_int()?;
        let stride = __reader.read_int()?;
        let format = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self {
            id,
            offset,
            width,
            height,
            stride,
            format,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        __packet.push_int(self.offset);
        __packet.push_int(self.width);
        __packet.push_int(self.height);
        __packet.push_int(self.stride);
        __packet.push_uint(self.format);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shm_pool_v2_request_create_buffer_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shm_pool_v2_request_create_buffer_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shm_pool_v2_request_create_buffer_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shm_pool_v2_request_destroy_args {}
impl wl_shm_pool_v2_request_destroy_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shm_pool_v2_request_destroy_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shm_pool_v2_request_destroy_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shm_pool_v2_request_destroy_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shm_pool_v2_request_destroy_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shm_pool_v2_request_resize_args {
    size: i32,
}
impl wl_shm_pool_v2_request_resize_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shm_pool_v2_request_resize_args, crate::Error> {
        let mut __reader = __value.read();
        let size = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self { size })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.size);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shm_pool_v2_request_resize_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shm_pool_v2_request_resize_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shm_pool_v2_request_resize_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait wl_shm_v2_event_handler: crate::protocol::EventHandler {
    fn handle_format(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        format: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let format = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_format(__connection, __packet, format).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_shm_v2_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_shm_v2_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_create_pool(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
        fd: ::std::os::fd::RawFd,
        size: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        __packet.push_fd(fd);
        __packet.push_int(size);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_release(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_shm_v2_request_create_pool_args {
    id: crate::NewObjectId,
    fd: ::std::os::fd::RawFd,
    size: i32,
}
impl wl_shm_v2_request_create_pool_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shm_v2_request_create_pool_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        let fd = __reader.read_fd()?;
        let size = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self { id, fd, size })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        __packet.push_fd(self.fd);
        __packet.push_int(self.size);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shm_v2_request_create_pool_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shm_v2_request_create_pool_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shm_v2_request_create_pool_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shm_v2_request_release_args {}
impl wl_shm_v2_request_release_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shm_v2_request_release_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shm_v2_request_release_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shm_v2_request_release_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shm_v2_request_release_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shm_v2_event_format_args {
    format: u32,
}
impl wl_shm_v2_event_format_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shm_v2_event_format_args, crate::Error> {
        let mut __reader = __value.read();
        let format = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { format })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.format);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shm_v2_event_format_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shm_v2_event_format_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shm_v2_event_format_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait wl_buffer_v1_event_handler: crate::protocol::EventHandler {
    fn handle_release(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_release(__connection, __packet).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_buffer_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_buffer_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_buffer_v1_request_destroy_args {}
impl wl_buffer_v1_request_destroy_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_buffer_v1_request_destroy_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_buffer_v1_request_destroy_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_buffer_v1_request_destroy_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_buffer_v1_request_destroy_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_buffer_v1_event_release_args {}
impl wl_buffer_v1_event_release_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_buffer_v1_event_release_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_buffer_v1_event_release_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_buffer_v1_event_release_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_buffer_v1_event_release_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait wl_data_offer_v3_event_handler: crate::protocol::EventHandler {
    fn handle_offer(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        mime_type: ::std::string::String,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_source_actions(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        source_actions: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_action(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        dnd_action: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let mime_type = __packet_reader.read_str()?;
                    __packet_reader.finish()?;
                    self.handle_offer(__connection, __packet, mime_type).await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let source_actions = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_source_actions(__connection, __packet, source_actions)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    let dnd_action = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_action(__connection, __packet, dnd_action).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_data_offer_v3_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_data_offer_v3_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_accept(
        &self,
        __object_id: crate::ObjectId,
        serial: u32,
        mime_type: &str,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_uint(serial);
        __packet.push_str(&mime_type);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_receive(
        &self,
        __object_id: crate::ObjectId,
        mime_type: &str,
        fd: ::std::os::fd::RawFd,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_str(&mime_type);
        __packet.push_fd(fd);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_finish(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 3);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_actions(
        &self,
        __object_id: crate::ObjectId,
        dnd_actions: u32,
        preferred_action: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 4);
        __packet.push_uint(dnd_actions);
        __packet.push_uint(preferred_action);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_data_offer_v3_request_accept_args {
    serial: u32,
    mime_type: ::std::string::String,
}
impl wl_data_offer_v3_request_accept_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_offer_v3_request_accept_args, crate::Error> {
        let mut __reader = __value.read();
        let serial = __reader.read_uint()?;
        let mime_type = __reader.read_str()?;
        __reader.finish()?;
        Ok(Self { serial, mime_type })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.serial);
        __packet.push_str(&self.mime_type);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_offer_v3_request_accept_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_offer_v3_request_accept_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_offer_v3_request_accept_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_offer_v3_request_receive_args {
    mime_type: ::std::string::String,
    fd: ::std::os::fd::RawFd,
}
impl wl_data_offer_v3_request_receive_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_offer_v3_request_receive_args, crate::Error> {
        let mut __reader = __value.read();
        let mime_type = __reader.read_str()?;
        let fd = __reader.read_fd()?;
        __reader.finish()?;
        Ok(Self { mime_type, fd })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_str(&self.mime_type);
        __packet.push_fd(self.fd);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_offer_v3_request_receive_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_offer_v3_request_receive_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_offer_v3_request_receive_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_offer_v3_request_destroy_args {}
impl wl_data_offer_v3_request_destroy_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_offer_v3_request_destroy_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_offer_v3_request_destroy_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_offer_v3_request_destroy_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_offer_v3_request_destroy_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_offer_v3_request_finish_args {}
impl wl_data_offer_v3_request_finish_args {
    pub const OPCODE: u16 = 3;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_offer_v3_request_finish_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_offer_v3_request_finish_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_offer_v3_request_finish_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_offer_v3_request_finish_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_offer_v3_request_set_actions_args {
    dnd_actions: u32,
    preferred_action: u32,
}
impl wl_data_offer_v3_request_set_actions_args {
    pub const OPCODE: u16 = 4;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_offer_v3_request_set_actions_args, crate::Error> {
        let mut __reader = __value.read();
        let dnd_actions = __reader.read_uint()?;
        let preferred_action = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self {
            dnd_actions,
            preferred_action,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.dnd_actions);
        __packet.push_uint(self.preferred_action);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_offer_v3_request_set_actions_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_offer_v3_request_set_actions_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_offer_v3_request_set_actions_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_offer_v3_event_offer_args {
    mime_type: ::std::string::String,
}
impl wl_data_offer_v3_event_offer_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_offer_v3_event_offer_args, crate::Error> {
        let mut __reader = __value.read();
        let mime_type = __reader.read_str()?;
        __reader.finish()?;
        Ok(Self { mime_type })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_str(&self.mime_type);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_offer_v3_event_offer_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_offer_v3_event_offer_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_offer_v3_event_offer_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_offer_v3_event_source_actions_args {
    source_actions: u32,
}
impl wl_data_offer_v3_event_source_actions_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_offer_v3_event_source_actions_args, crate::Error> {
        let mut __reader = __value.read();
        let source_actions = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { source_actions })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.source_actions);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_offer_v3_event_source_actions_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_offer_v3_event_source_actions_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_offer_v3_event_source_actions_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_offer_v3_event_action_args {
    dnd_action: u32,
}
impl wl_data_offer_v3_event_action_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_offer_v3_event_action_args, crate::Error> {
        let mut __reader = __value.read();
        let dnd_action = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { dnd_action })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.dnd_action);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_offer_v3_event_action_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_offer_v3_event_action_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_offer_v3_event_action_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait wl_data_source_v3_event_handler: crate::protocol::EventHandler {
    fn handle_target(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        mime_type: ::std::string::String,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_send(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        mime_type: ::std::string::String,
        fd: ::std::os::fd::RawFd,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_cancelled(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_dnd_drop_performed(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_dnd_finished(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_action(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        dnd_action: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let mime_type = __packet_reader.read_str()?;
                    __packet_reader.finish()?;
                    self.handle_target(__connection, __packet, mime_type).await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let mime_type = __packet_reader.read_str()?;
                    let fd = __packet_reader.read_fd()?;
                    __packet_reader.finish()?;
                    self.handle_send(__connection, __packet, mime_type, fd)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_cancelled(__connection, __packet).await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_dnd_drop_performed(__connection, __packet).await;
                    Ok(())
                }
                4 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_dnd_finished(__connection, __packet).await;
                    Ok(())
                }
                5 => {
                    let mut __packet_reader = __packet.read();
                    let dnd_action = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_action(__connection, __packet, dnd_action).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_data_source_v3_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_data_source_v3_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_offer(
        &self,
        __object_id: crate::ObjectId,
        mime_type: &str,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_str(&mime_type);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_actions(
        &self,
        __object_id: crate::ObjectId,
        dnd_actions: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_uint(dnd_actions);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_data_source_v3_request_offer_args {
    mime_type: ::std::string::String,
}
impl wl_data_source_v3_request_offer_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_source_v3_request_offer_args, crate::Error> {
        let mut __reader = __value.read();
        let mime_type = __reader.read_str()?;
        __reader.finish()?;
        Ok(Self { mime_type })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_str(&self.mime_type);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_source_v3_request_offer_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_source_v3_request_offer_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_source_v3_request_offer_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_source_v3_request_destroy_args {}
impl wl_data_source_v3_request_destroy_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_source_v3_request_destroy_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_source_v3_request_destroy_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_source_v3_request_destroy_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_source_v3_request_destroy_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_source_v3_request_set_actions_args {
    dnd_actions: u32,
}
impl wl_data_source_v3_request_set_actions_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_source_v3_request_set_actions_args, crate::Error> {
        let mut __reader = __value.read();
        let dnd_actions = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { dnd_actions })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.dnd_actions);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_source_v3_request_set_actions_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_source_v3_request_set_actions_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_source_v3_request_set_actions_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_source_v3_event_target_args {
    mime_type: ::std::string::String,
}
impl wl_data_source_v3_event_target_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_source_v3_event_target_args, crate::Error> {
        let mut __reader = __value.read();
        let mime_type = __reader.read_str()?;
        __reader.finish()?;
        Ok(Self { mime_type })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_str(&self.mime_type);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_source_v3_event_target_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_source_v3_event_target_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_source_v3_event_target_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_source_v3_event_send_args {
    mime_type: ::std::string::String,
    fd: ::std::os::fd::RawFd,
}
impl wl_data_source_v3_event_send_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_source_v3_event_send_args, crate::Error> {
        let mut __reader = __value.read();
        let mime_type = __reader.read_str()?;
        let fd = __reader.read_fd()?;
        __reader.finish()?;
        Ok(Self { mime_type, fd })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_str(&self.mime_type);
        __packet.push_fd(self.fd);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_source_v3_event_send_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_source_v3_event_send_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_source_v3_event_send_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_source_v3_event_cancelled_args {}
impl wl_data_source_v3_event_cancelled_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_source_v3_event_cancelled_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_source_v3_event_cancelled_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_source_v3_event_cancelled_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_source_v3_event_cancelled_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_source_v3_event_dnd_drop_performed_args {}
impl wl_data_source_v3_event_dnd_drop_performed_args {
    pub const OPCODE: u16 = 3;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_source_v3_event_dnd_drop_performed_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_source_v3_event_dnd_drop_performed_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_data_source_v3_event_dnd_drop_performed_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_data_source_v3_event_dnd_drop_performed_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_source_v3_event_dnd_finished_args {}
impl wl_data_source_v3_event_dnd_finished_args {
    pub const OPCODE: u16 = 4;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_source_v3_event_dnd_finished_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_source_v3_event_dnd_finished_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_source_v3_event_dnd_finished_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_source_v3_event_dnd_finished_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_source_v3_event_action_args {
    dnd_action: u32,
}
impl wl_data_source_v3_event_action_args {
    pub const OPCODE: u16 = 5;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_source_v3_event_action_args, crate::Error> {
        let mut __reader = __value.read();
        let dnd_action = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { dnd_action })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.dnd_action);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_source_v3_event_action_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_source_v3_event_action_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_source_v3_event_action_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait wl_data_device_v3_event_handler: crate::protocol::EventHandler {
    fn handle_data_offer(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        id: crate::NewObjectId,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_enter(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        surface: ::std::option::Option<crate::ObjectId>,
        x: crate::Fixed,
        y: crate::Fixed,
        id: ::std::option::Option<crate::ObjectId>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_leave(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_motion(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        time: u32,
        x: crate::Fixed,
        y: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_drop(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_selection(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        id: ::std::option::Option<crate::ObjectId>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let id = __packet_reader.read_new_id_known_interface()?;
                    __packet_reader.finish()?;
                    self.handle_data_offer(__connection, __packet, id).await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let surface = __packet_reader.read_object()?;
                    let x = __packet_reader.read_fixed()?;
                    let y = __packet_reader.read_fixed()?;
                    let id = __packet_reader.read_object()?;
                    __packet_reader.finish()?;
                    self.handle_enter(__connection, __packet, serial, surface, x, y, id)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_leave(__connection, __packet).await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    let time = __packet_reader.read_uint()?;
                    let x = __packet_reader.read_fixed()?;
                    let y = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_motion(__connection, __packet, time, x, y).await;
                    Ok(())
                }
                4 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_drop(__connection, __packet).await;
                    Ok(())
                }
                5 => {
                    let mut __packet_reader = __packet.read();
                    let id = __packet_reader.read_object()?;
                    __packet_reader.finish()?;
                    self.handle_selection(__connection, __packet, id).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_data_device_v3_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_data_device_v3_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_start_drag(
        &self,
        __object_id: crate::ObjectId,
        source: ::std::option::Option<crate::ObjectId>,
        origin: ::std::option::Option<crate::ObjectId>,
        icon: ::std::option::Option<crate::ObjectId>,
        serial: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_object(source);
        __packet.push_object(origin);
        __packet.push_object(icon);
        __packet.push_uint(serial);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_selection(
        &self,
        __object_id: crate::ObjectId,
        source: ::std::option::Option<crate::ObjectId>,
        serial: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_object(source);
        __packet.push_uint(serial);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_release(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_data_device_v3_request_start_drag_args {
    source: ::std::option::Option<crate::ObjectId>,
    origin: ::std::option::Option<crate::ObjectId>,
    icon: ::std::option::Option<crate::ObjectId>,
    serial: u32,
}
impl wl_data_device_v3_request_start_drag_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_device_v3_request_start_drag_args, crate::Error> {
        let mut __reader = __value.read();
        let source = __reader.read_object()?;
        let origin = __reader.read_object()?;
        let icon = __reader.read_object()?;
        let serial = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self {
            source,
            origin,
            icon,
            serial,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.source);
        __packet.push_object(self.origin);
        __packet.push_object(self.icon);
        __packet.push_uint(self.serial);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_device_v3_request_start_drag_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_device_v3_request_start_drag_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_device_v3_request_start_drag_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_device_v3_request_set_selection_args {
    source: ::std::option::Option<crate::ObjectId>,
    serial: u32,
}
impl wl_data_device_v3_request_set_selection_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_device_v3_request_set_selection_args, crate::Error> {
        let mut __reader = __value.read();
        let source = __reader.read_object()?;
        let serial = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { source, serial })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.source);
        __packet.push_uint(self.serial);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_device_v3_request_set_selection_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_data_device_v3_request_set_selection_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_data_device_v3_request_set_selection_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_device_v3_request_release_args {}
impl wl_data_device_v3_request_release_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_device_v3_request_release_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_device_v3_request_release_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_device_v3_request_release_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_device_v3_request_release_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_device_v3_event_data_offer_args {
    id: crate::NewObjectId,
}
impl wl_data_device_v3_event_data_offer_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_device_v3_event_data_offer_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        __reader.finish()?;
        Ok(Self { id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_device_v3_event_data_offer_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_device_v3_event_data_offer_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_device_v3_event_data_offer_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_device_v3_event_enter_args {
    serial: u32,
    surface: ::std::option::Option<crate::ObjectId>,
    x: crate::Fixed,
    y: crate::Fixed,
    id: ::std::option::Option<crate::ObjectId>,
}
impl wl_data_device_v3_event_enter_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_device_v3_event_enter_args, crate::Error> {
        let mut __reader = __value.read();
        let serial = __reader.read_uint()?;
        let surface = __reader.read_object()?;
        let x = __reader.read_fixed()?;
        let y = __reader.read_fixed()?;
        let id = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self {
            serial,
            surface,
            x,
            y,
            id,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.serial);
        __packet.push_object(self.surface);
        __packet.push_fixed(self.x);
        __packet.push_fixed(self.y);
        __packet.push_object(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_device_v3_event_enter_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_device_v3_event_enter_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_device_v3_event_enter_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_device_v3_event_leave_args {}
impl wl_data_device_v3_event_leave_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_device_v3_event_leave_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_device_v3_event_leave_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_device_v3_event_leave_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_device_v3_event_leave_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_device_v3_event_motion_args {
    time: u32,
    x: crate::Fixed,
    y: crate::Fixed,
}
impl wl_data_device_v3_event_motion_args {
    pub const OPCODE: u16 = 3;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_device_v3_event_motion_args, crate::Error> {
        let mut __reader = __value.read();
        let time = __reader.read_uint()?;
        let x = __reader.read_fixed()?;
        let y = __reader.read_fixed()?;
        __reader.finish()?;
        Ok(Self { time, x, y })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.time);
        __packet.push_fixed(self.x);
        __packet.push_fixed(self.y);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_device_v3_event_motion_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_device_v3_event_motion_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_device_v3_event_motion_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_device_v3_event_drop_args {}
impl wl_data_device_v3_event_drop_args {
    pub const OPCODE: u16 = 4;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_device_v3_event_drop_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_device_v3_event_drop_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_device_v3_event_drop_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_device_v3_event_drop_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_device_v3_event_selection_args {
    id: ::std::option::Option<crate::ObjectId>,
}
impl wl_data_device_v3_event_selection_args {
    pub const OPCODE: u16 = 5;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_device_v3_event_selection_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_data_device_v3_event_selection_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_data_device_v3_event_selection_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_data_device_v3_event_selection_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub struct wl_data_device_manager_v3_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_data_device_manager_v3_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_create_data_source(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_data_device(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
        seat: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(id);
        __packet.push_object(seat);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_data_device_manager_v3_request_create_data_source_args {
    id: crate::NewObjectId,
}
impl wl_data_device_manager_v3_request_create_data_source_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_device_manager_v3_request_create_data_source_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        __reader.finish()?;
        Ok(Self { id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet>
    for wl_data_device_manager_v3_request_create_data_source_args
{
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_data_device_manager_v3_request_create_data_source_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_data_device_manager_v3_request_create_data_source_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_data_device_manager_v3_request_get_data_device_args {
    id: crate::NewObjectId,
    seat: ::std::option::Option<crate::ObjectId>,
}
impl wl_data_device_manager_v3_request_get_data_device_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_data_device_manager_v3_request_get_data_device_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        let seat = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { id, seat })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        __packet.push_object(self.seat);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet>
    for wl_data_device_manager_v3_request_get_data_device_args
{
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_data_device_manager_v3_request_get_data_device_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_data_device_manager_v3_request_get_data_device_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub struct wl_shell_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_shell_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_get_shell_surface(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
        surface: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        __packet.push_object(surface);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_shell_v1_request_get_shell_surface_args {
    id: crate::NewObjectId,
    surface: ::std::option::Option<crate::ObjectId>,
}
impl wl_shell_v1_request_get_shell_surface_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shell_v1_request_get_shell_surface_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        let surface = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { id, surface })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        __packet.push_object(self.surface);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shell_v1_request_get_shell_surface_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shell_v1_request_get_shell_surface_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shell_v1_request_get_shell_surface_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait wl_shell_surface_v1_event_handler: crate::protocol::EventHandler {
    fn handle_ping(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_configure(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        edges: u32,
        width: i32,
        height: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_popup_done(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_ping(__connection, __packet, serial).await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let edges = __packet_reader.read_uint()?;
                    let width = __packet_reader.read_int()?;
                    let height = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_configure(__connection, __packet, edges, width, height)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_popup_done(__connection, __packet).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_shell_surface_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_shell_surface_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_pong(
        &self,
        __object_id: crate::ObjectId,
        serial: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_uint(serial);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_move(
        &self,
        __object_id: crate::ObjectId,
        seat: ::std::option::Option<crate::ObjectId>,
        serial: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_object(seat);
        __packet.push_uint(serial);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_resize(
        &self,
        __object_id: crate::ObjectId,
        seat: ::std::option::Option<crate::ObjectId>,
        serial: u32,
        edges: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_object(seat);
        __packet.push_uint(serial);
        __packet.push_uint(edges);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_toplevel(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 3);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_transient(
        &self,
        __object_id: crate::ObjectId,
        parent: ::std::option::Option<crate::ObjectId>,
        x: i32,
        y: i32,
        flags: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 4);
        __packet.push_object(parent);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_uint(flags);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_fullscreen(
        &self,
        __object_id: crate::ObjectId,
        method: u32,
        framerate: u32,
        output: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 5);
        __packet.push_uint(method);
        __packet.push_uint(framerate);
        __packet.push_object(output);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_popup(
        &self,
        __object_id: crate::ObjectId,
        seat: ::std::option::Option<crate::ObjectId>,
        serial: u32,
        parent: ::std::option::Option<crate::ObjectId>,
        x: i32,
        y: i32,
        flags: u32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 6);
        __packet.push_object(seat);
        __packet.push_uint(serial);
        __packet.push_object(parent);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_uint(flags);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_maximized(
        &self,
        __object_id: crate::ObjectId,
        output: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 7);
        __packet.push_object(output);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_title(
        &self,
        __object_id: crate::ObjectId,
        title: &str,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 8);
        __packet.push_str(&title);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_class(
        &self,
        __object_id: crate::ObjectId,
        class_: &str,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 9);
        __packet.push_str(&class_);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_shell_surface_v1_request_pong_args {
    serial: u32,
}
impl wl_shell_surface_v1_request_pong_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shell_surface_v1_request_pong_args, crate::Error> {
        let mut __reader = __value.read();
        let serial = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { serial })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.serial);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shell_surface_v1_request_pong_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shell_surface_v1_request_pong_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shell_surface_v1_request_pong_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shell_surface_v1_request_move_args {
    seat: ::std::option::Option<crate::ObjectId>,
    serial: u32,
}
impl wl_shell_surface_v1_request_move_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shell_surface_v1_request_move_args, crate::Error> {
        let mut __reader = __value.read();
        let seat = __reader.read_object()?;
        let serial = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { seat, serial })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.seat);
        __packet.push_uint(self.serial);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shell_surface_v1_request_move_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shell_surface_v1_request_move_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shell_surface_v1_request_move_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shell_surface_v1_request_resize_args {
    seat: ::std::option::Option<crate::ObjectId>,
    serial: u32,
    edges: u32,
}
impl wl_shell_surface_v1_request_resize_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shell_surface_v1_request_resize_args, crate::Error> {
        let mut __reader = __value.read();
        let seat = __reader.read_object()?;
        let serial = __reader.read_uint()?;
        let edges = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self {
            seat,
            serial,
            edges,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.seat);
        __packet.push_uint(self.serial);
        __packet.push_uint(self.edges);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shell_surface_v1_request_resize_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shell_surface_v1_request_resize_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shell_surface_v1_request_resize_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shell_surface_v1_request_set_toplevel_args {}
impl wl_shell_surface_v1_request_set_toplevel_args {
    pub const OPCODE: u16 = 3;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shell_surface_v1_request_set_toplevel_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shell_surface_v1_request_set_toplevel_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_shell_surface_v1_request_set_toplevel_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_shell_surface_v1_request_set_toplevel_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shell_surface_v1_request_set_transient_args {
    parent: ::std::option::Option<crate::ObjectId>,
    x: i32,
    y: i32,
    flags: u32,
}
impl wl_shell_surface_v1_request_set_transient_args {
    pub const OPCODE: u16 = 4;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shell_surface_v1_request_set_transient_args, crate::Error> {
        let mut __reader = __value.read();
        let parent = __reader.read_object()?;
        let x = __reader.read_int()?;
        let y = __reader.read_int()?;
        let flags = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self {
            parent,
            x,
            y,
            flags,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.parent);
        __packet.push_int(self.x);
        __packet.push_int(self.y);
        __packet.push_uint(self.flags);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shell_surface_v1_request_set_transient_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_shell_surface_v1_request_set_transient_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_shell_surface_v1_request_set_transient_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shell_surface_v1_request_set_fullscreen_args {
    method: u32,
    framerate: u32,
    output: ::std::option::Option<crate::ObjectId>,
}
impl wl_shell_surface_v1_request_set_fullscreen_args {
    pub const OPCODE: u16 = 5;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shell_surface_v1_request_set_fullscreen_args, crate::Error> {
        let mut __reader = __value.read();
        let method = __reader.read_uint()?;
        let framerate = __reader.read_uint()?;
        let output = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self {
            method,
            framerate,
            output,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.method);
        __packet.push_uint(self.framerate);
        __packet.push_object(self.output);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shell_surface_v1_request_set_fullscreen_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_shell_surface_v1_request_set_fullscreen_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_shell_surface_v1_request_set_fullscreen_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shell_surface_v1_request_set_popup_args {
    seat: ::std::option::Option<crate::ObjectId>,
    serial: u32,
    parent: ::std::option::Option<crate::ObjectId>,
    x: i32,
    y: i32,
    flags: u32,
}
impl wl_shell_surface_v1_request_set_popup_args {
    pub const OPCODE: u16 = 6;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shell_surface_v1_request_set_popup_args, crate::Error> {
        let mut __reader = __value.read();
        let seat = __reader.read_object()?;
        let serial = __reader.read_uint()?;
        let parent = __reader.read_object()?;
        let x = __reader.read_int()?;
        let y = __reader.read_int()?;
        let flags = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self {
            seat,
            serial,
            parent,
            x,
            y,
            flags,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.seat);
        __packet.push_uint(self.serial);
        __packet.push_object(self.parent);
        __packet.push_int(self.x);
        __packet.push_int(self.y);
        __packet.push_uint(self.flags);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shell_surface_v1_request_set_popup_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shell_surface_v1_request_set_popup_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shell_surface_v1_request_set_popup_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shell_surface_v1_request_set_maximized_args {
    output: ::std::option::Option<crate::ObjectId>,
}
impl wl_shell_surface_v1_request_set_maximized_args {
    pub const OPCODE: u16 = 7;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shell_surface_v1_request_set_maximized_args, crate::Error> {
        let mut __reader = __value.read();
        let output = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { output })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.output);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shell_surface_v1_request_set_maximized_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_shell_surface_v1_request_set_maximized_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_shell_surface_v1_request_set_maximized_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shell_surface_v1_request_set_title_args {
    title: ::std::string::String,
}
impl wl_shell_surface_v1_request_set_title_args {
    pub const OPCODE: u16 = 8;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shell_surface_v1_request_set_title_args, crate::Error> {
        let mut __reader = __value.read();
        let title = __reader.read_str()?;
        __reader.finish()?;
        Ok(Self { title })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_str(&self.title);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shell_surface_v1_request_set_title_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shell_surface_v1_request_set_title_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shell_surface_v1_request_set_title_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shell_surface_v1_request_set_class_args {
    class_: ::std::string::String,
}
impl wl_shell_surface_v1_request_set_class_args {
    pub const OPCODE: u16 = 9;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shell_surface_v1_request_set_class_args, crate::Error> {
        let mut __reader = __value.read();
        let class_ = __reader.read_str()?;
        __reader.finish()?;
        Ok(Self { class_ })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_str(&self.class_);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shell_surface_v1_request_set_class_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shell_surface_v1_request_set_class_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shell_surface_v1_request_set_class_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shell_surface_v1_event_ping_args {
    serial: u32,
}
impl wl_shell_surface_v1_event_ping_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shell_surface_v1_event_ping_args, crate::Error> {
        let mut __reader = __value.read();
        let serial = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { serial })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.serial);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shell_surface_v1_event_ping_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shell_surface_v1_event_ping_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shell_surface_v1_event_ping_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shell_surface_v1_event_configure_args {
    edges: u32,
    width: i32,
    height: i32,
}
impl wl_shell_surface_v1_event_configure_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shell_surface_v1_event_configure_args, crate::Error> {
        let mut __reader = __value.read();
        let edges = __reader.read_uint()?;
        let width = __reader.read_int()?;
        let height = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self {
            edges,
            width,
            height,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.edges);
        __packet.push_int(self.width);
        __packet.push_int(self.height);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shell_surface_v1_event_configure_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shell_surface_v1_event_configure_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shell_surface_v1_event_configure_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_shell_surface_v1_event_popup_done_args {}
impl wl_shell_surface_v1_event_popup_done_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_shell_surface_v1_event_popup_done_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_shell_surface_v1_event_popup_done_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_shell_surface_v1_event_popup_done_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_shell_surface_v1_event_popup_done_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait wl_surface_v6_event_handler: crate::protocol::EventHandler {
    fn handle_enter(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        output: ::std::option::Option<crate::ObjectId>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_leave(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        output: ::std::option::Option<crate::ObjectId>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_preferred_buffer_scale(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        factor: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_preferred_buffer_transform(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        transform: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let output = __packet_reader.read_object()?;
                    __packet_reader.finish()?;
                    self.handle_enter(__connection, __packet, output).await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let output = __packet_reader.read_object()?;
                    __packet_reader.finish()?;
                    self.handle_leave(__connection, __packet, output).await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    let factor = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_preferred_buffer_scale(__connection, __packet, factor)
                        .await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    let transform = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_preferred_buffer_transform(__connection, __packet, transform)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_surface_v6_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_surface_v6_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_attach(
        &self,
        __object_id: crate::ObjectId,
        buffer: ::std::option::Option<crate::ObjectId>,
        x: i32,
        y: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_object(buffer);
        __packet.push_int(x);
        __packet.push_int(y);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_damage(
        &self,
        __object_id: crate::ObjectId,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_int(width);
        __packet.push_int(height);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_frame(
        &self,
        __object_id: crate::ObjectId,
        callback: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 3);
        __packet.push_new_id_known_interface(callback);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_opaque_region(
        &self,
        __object_id: crate::ObjectId,
        region: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 4);
        __packet.push_object(region);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_input_region(
        &self,
        __object_id: crate::ObjectId,
        region: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 5);
        __packet.push_object(region);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_commit(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 6);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_buffer_transform(
        &self,
        __object_id: crate::ObjectId,
        transform: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 7);
        __packet.push_int(transform);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_buffer_scale(
        &self,
        __object_id: crate::ObjectId,
        scale: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 8);
        __packet.push_int(scale);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_damage_buffer(
        &self,
        __object_id: crate::ObjectId,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 9);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_int(width);
        __packet.push_int(height);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_offset(
        &self,
        __object_id: crate::ObjectId,
        x: i32,
        y: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 10);
        __packet.push_int(x);
        __packet.push_int(y);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_surface_v6_request_destroy_args {}
impl wl_surface_v6_request_destroy_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_request_destroy_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_surface_v6_request_destroy_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_surface_v6_request_destroy_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_surface_v6_request_destroy_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_surface_v6_request_attach_args {
    buffer: ::std::option::Option<crate::ObjectId>,
    x: i32,
    y: i32,
}
impl wl_surface_v6_request_attach_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_request_attach_args, crate::Error> {
        let mut __reader = __value.read();
        let buffer = __reader.read_object()?;
        let x = __reader.read_int()?;
        let y = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self { buffer, x, y })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.buffer);
        __packet.push_int(self.x);
        __packet.push_int(self.y);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_surface_v6_request_attach_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_surface_v6_request_attach_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_surface_v6_request_attach_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_surface_v6_request_damage_args {
    x: i32,
    y: i32,
    width: i32,
    height: i32,
}
impl wl_surface_v6_request_damage_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_request_damage_args, crate::Error> {
        let mut __reader = __value.read();
        let x = __reader.read_int()?;
        let y = __reader.read_int()?;
        let width = __reader.read_int()?;
        let height = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self {
            x,
            y,
            width,
            height,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.x);
        __packet.push_int(self.y);
        __packet.push_int(self.width);
        __packet.push_int(self.height);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_surface_v6_request_damage_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_surface_v6_request_damage_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_surface_v6_request_damage_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_surface_v6_request_frame_args {
    callback: crate::NewObjectId,
}
impl wl_surface_v6_request_frame_args {
    pub const OPCODE: u16 = 3;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_request_frame_args, crate::Error> {
        let mut __reader = __value.read();
        let callback = __reader.read_new_id_known_interface()?;
        __reader.finish()?;
        Ok(Self { callback })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.callback);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_surface_v6_request_frame_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_surface_v6_request_frame_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_surface_v6_request_frame_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_surface_v6_request_set_opaque_region_args {
    region: ::std::option::Option<crate::ObjectId>,
}
impl wl_surface_v6_request_set_opaque_region_args {
    pub const OPCODE: u16 = 4;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_request_set_opaque_region_args, crate::Error> {
        let mut __reader = __value.read();
        let region = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { region })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.region);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_surface_v6_request_set_opaque_region_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_surface_v6_request_set_opaque_region_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_surface_v6_request_set_opaque_region_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_surface_v6_request_set_input_region_args {
    region: ::std::option::Option<crate::ObjectId>,
}
impl wl_surface_v6_request_set_input_region_args {
    pub const OPCODE: u16 = 5;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_request_set_input_region_args, crate::Error> {
        let mut __reader = __value.read();
        let region = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { region })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.region);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_surface_v6_request_set_input_region_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_surface_v6_request_set_input_region_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_surface_v6_request_set_input_region_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_surface_v6_request_commit_args {}
impl wl_surface_v6_request_commit_args {
    pub const OPCODE: u16 = 6;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_request_commit_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_surface_v6_request_commit_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_surface_v6_request_commit_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_surface_v6_request_commit_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_surface_v6_request_set_buffer_transform_args {
    transform: i32,
}
impl wl_surface_v6_request_set_buffer_transform_args {
    pub const OPCODE: u16 = 7;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_request_set_buffer_transform_args, crate::Error> {
        let mut __reader = __value.read();
        let transform = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self { transform })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.transform);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_surface_v6_request_set_buffer_transform_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_surface_v6_request_set_buffer_transform_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_surface_v6_request_set_buffer_transform_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_surface_v6_request_set_buffer_scale_args {
    scale: i32,
}
impl wl_surface_v6_request_set_buffer_scale_args {
    pub const OPCODE: u16 = 8;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_request_set_buffer_scale_args, crate::Error> {
        let mut __reader = __value.read();
        let scale = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self { scale })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.scale);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_surface_v6_request_set_buffer_scale_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_surface_v6_request_set_buffer_scale_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_surface_v6_request_set_buffer_scale_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_surface_v6_request_damage_buffer_args {
    x: i32,
    y: i32,
    width: i32,
    height: i32,
}
impl wl_surface_v6_request_damage_buffer_args {
    pub const OPCODE: u16 = 9;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_request_damage_buffer_args, crate::Error> {
        let mut __reader = __value.read();
        let x = __reader.read_int()?;
        let y = __reader.read_int()?;
        let width = __reader.read_int()?;
        let height = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self {
            x,
            y,
            width,
            height,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.x);
        __packet.push_int(self.y);
        __packet.push_int(self.width);
        __packet.push_int(self.height);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_surface_v6_request_damage_buffer_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_surface_v6_request_damage_buffer_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_surface_v6_request_damage_buffer_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_surface_v6_request_offset_args {
    x: i32,
    y: i32,
}
impl wl_surface_v6_request_offset_args {
    pub const OPCODE: u16 = 10;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_request_offset_args, crate::Error> {
        let mut __reader = __value.read();
        let x = __reader.read_int()?;
        let y = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self { x, y })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.x);
        __packet.push_int(self.y);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_surface_v6_request_offset_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_surface_v6_request_offset_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_surface_v6_request_offset_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_surface_v6_event_enter_args {
    output: ::std::option::Option<crate::ObjectId>,
}
impl wl_surface_v6_event_enter_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_event_enter_args, crate::Error> {
        let mut __reader = __value.read();
        let output = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { output })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.output);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_surface_v6_event_enter_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_surface_v6_event_enter_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_surface_v6_event_enter_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_surface_v6_event_leave_args {
    output: ::std::option::Option<crate::ObjectId>,
}
impl wl_surface_v6_event_leave_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_event_leave_args, crate::Error> {
        let mut __reader = __value.read();
        let output = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { output })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.output);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_surface_v6_event_leave_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_surface_v6_event_leave_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_surface_v6_event_leave_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_surface_v6_event_preferred_buffer_scale_args {
    factor: i32,
}
impl wl_surface_v6_event_preferred_buffer_scale_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_event_preferred_buffer_scale_args, crate::Error> {
        let mut __reader = __value.read();
        let factor = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self { factor })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.factor);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_surface_v6_event_preferred_buffer_scale_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_surface_v6_event_preferred_buffer_scale_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_surface_v6_event_preferred_buffer_scale_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_surface_v6_event_preferred_buffer_transform_args {
    transform: u32,
}
impl wl_surface_v6_event_preferred_buffer_transform_args {
    pub const OPCODE: u16 = 3;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_surface_v6_event_preferred_buffer_transform_args, crate::Error> {
        let mut __reader = __value.read();
        let transform = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { transform })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.transform);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet>
    for wl_surface_v6_event_preferred_buffer_transform_args
{
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_surface_v6_event_preferred_buffer_transform_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_surface_v6_event_preferred_buffer_transform_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait wl_seat_v10_event_handler: crate::protocol::EventHandler {
    fn handle_capabilities(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        capabilities: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_name(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        name: ::std::string::String,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let capabilities = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_capabilities(__connection, __packet, capabilities)
                        .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let name = __packet_reader.read_str()?;
                    __packet_reader.finish()?;
                    self.handle_name(__connection, __packet, name).await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_seat_v10_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_seat_v10_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_get_pointer(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_keyboard(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_touch(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_new_id_known_interface(id);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_release(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 3);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_seat_v10_request_get_pointer_args {
    id: crate::NewObjectId,
}
impl wl_seat_v10_request_get_pointer_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_seat_v10_request_get_pointer_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        __reader.finish()?;
        Ok(Self { id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_seat_v10_request_get_pointer_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_seat_v10_request_get_pointer_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_seat_v10_request_get_pointer_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_seat_v10_request_get_keyboard_args {
    id: crate::NewObjectId,
}
impl wl_seat_v10_request_get_keyboard_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_seat_v10_request_get_keyboard_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        __reader.finish()?;
        Ok(Self { id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_seat_v10_request_get_keyboard_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_seat_v10_request_get_keyboard_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_seat_v10_request_get_keyboard_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_seat_v10_request_get_touch_args {
    id: crate::NewObjectId,
}
impl wl_seat_v10_request_get_touch_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_seat_v10_request_get_touch_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        __reader.finish()?;
        Ok(Self { id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_seat_v10_request_get_touch_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_seat_v10_request_get_touch_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_seat_v10_request_get_touch_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_seat_v10_request_release_args {}
impl wl_seat_v10_request_release_args {
    pub const OPCODE: u16 = 3;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_seat_v10_request_release_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_seat_v10_request_release_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_seat_v10_request_release_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_seat_v10_request_release_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_seat_v10_event_capabilities_args {
    capabilities: u32,
}
impl wl_seat_v10_event_capabilities_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_seat_v10_event_capabilities_args, crate::Error> {
        let mut __reader = __value.read();
        let capabilities = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { capabilities })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.capabilities);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_seat_v10_event_capabilities_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_seat_v10_event_capabilities_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_seat_v10_event_capabilities_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_seat_v10_event_name_args {
    name: ::std::string::String,
}
impl wl_seat_v10_event_name_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_seat_v10_event_name_args, crate::Error> {
        let mut __reader = __value.read();
        let name = __reader.read_str()?;
        __reader.finish()?;
        Ok(Self { name })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_str(&self.name);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_seat_v10_event_name_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_seat_v10_event_name_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_seat_v10_event_name_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait wl_pointer_v10_event_handler: crate::protocol::EventHandler {
    fn handle_enter(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        surface: ::std::option::Option<crate::ObjectId>,
        surface_x: crate::Fixed,
        surface_y: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_leave(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        surface: ::std::option::Option<crate::ObjectId>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_motion(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        time: u32,
        surface_x: crate::Fixed,
        surface_y: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_button(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        time: u32,
        button: u32,
        state: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_axis(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        time: u32,
        axis: u32,
        value: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_frame(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_axis_source(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        axis_source: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_axis_stop(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        time: u32,
        axis: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_axis_discrete(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        axis: u32,
        discrete: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_axis_value120(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        axis: u32,
        value120: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_axis_relative_direction(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        axis: u32,
        direction: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let surface = __packet_reader.read_object()?;
                    let surface_x = __packet_reader.read_fixed()?;
                    let surface_y = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_enter(
                        __connection,
                        __packet,
                        serial,
                        surface,
                        surface_x,
                        surface_y,
                    )
                    .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let surface = __packet_reader.read_object()?;
                    __packet_reader.finish()?;
                    self.handle_leave(__connection, __packet, serial, surface)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    let time = __packet_reader.read_uint()?;
                    let surface_x = __packet_reader.read_fixed()?;
                    let surface_y = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_motion(__connection, __packet, time, surface_x, surface_y)
                        .await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let time = __packet_reader.read_uint()?;
                    let button = __packet_reader.read_uint()?;
                    let state = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_button(__connection, __packet, serial, time, button, state)
                        .await;
                    Ok(())
                }
                4 => {
                    let mut __packet_reader = __packet.read();
                    let time = __packet_reader.read_uint()?;
                    let axis = __packet_reader.read_uint()?;
                    let value = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_axis(__connection, __packet, time, axis, value)
                        .await;
                    Ok(())
                }
                5 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_frame(__connection, __packet).await;
                    Ok(())
                }
                6 => {
                    let mut __packet_reader = __packet.read();
                    let axis_source = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_axis_source(__connection, __packet, axis_source)
                        .await;
                    Ok(())
                }
                7 => {
                    let mut __packet_reader = __packet.read();
                    let time = __packet_reader.read_uint()?;
                    let axis = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_axis_stop(__connection, __packet, time, axis)
                        .await;
                    Ok(())
                }
                8 => {
                    let mut __packet_reader = __packet.read();
                    let axis = __packet_reader.read_uint()?;
                    let discrete = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_axis_discrete(__connection, __packet, axis, discrete)
                        .await;
                    Ok(())
                }
                9 => {
                    let mut __packet_reader = __packet.read();
                    let axis = __packet_reader.read_uint()?;
                    let value120 = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_axis_value120(__connection, __packet, axis, value120)
                        .await;
                    Ok(())
                }
                10 => {
                    let mut __packet_reader = __packet.read();
                    let axis = __packet_reader.read_uint()?;
                    let direction = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_axis_relative_direction(__connection, __packet, axis, direction)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_pointer_v10_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_pointer_v10_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_set_cursor(
        &self,
        __object_id: crate::ObjectId,
        serial: u32,
        surface: ::std::option::Option<crate::ObjectId>,
        hotspot_x: i32,
        hotspot_y: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        __packet.push_uint(serial);
        __packet.push_object(surface);
        __packet.push_int(hotspot_x);
        __packet.push_int(hotspot_y);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_release(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_pointer_v10_request_set_cursor_args {
    serial: u32,
    surface: ::std::option::Option<crate::ObjectId>,
    hotspot_x: i32,
    hotspot_y: i32,
}
impl wl_pointer_v10_request_set_cursor_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_pointer_v10_request_set_cursor_args, crate::Error> {
        let mut __reader = __value.read();
        let serial = __reader.read_uint()?;
        let surface = __reader.read_object()?;
        let hotspot_x = __reader.read_int()?;
        let hotspot_y = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self {
            serial,
            surface,
            hotspot_x,
            hotspot_y,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.serial);
        __packet.push_object(self.surface);
        __packet.push_int(self.hotspot_x);
        __packet.push_int(self.hotspot_y);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_pointer_v10_request_set_cursor_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_pointer_v10_request_set_cursor_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_pointer_v10_request_set_cursor_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_pointer_v10_request_release_args {}
impl wl_pointer_v10_request_release_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_pointer_v10_request_release_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_pointer_v10_request_release_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_pointer_v10_request_release_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_pointer_v10_request_release_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_pointer_v10_event_enter_args {
    serial: u32,
    surface: ::std::option::Option<crate::ObjectId>,
    surface_x: crate::Fixed,
    surface_y: crate::Fixed,
}
impl wl_pointer_v10_event_enter_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_pointer_v10_event_enter_args, crate::Error> {
        let mut __reader = __value.read();
        let serial = __reader.read_uint()?;
        let surface = __reader.read_object()?;
        let surface_x = __reader.read_fixed()?;
        let surface_y = __reader.read_fixed()?;
        __reader.finish()?;
        Ok(Self {
            serial,
            surface,
            surface_x,
            surface_y,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.serial);
        __packet.push_object(self.surface);
        __packet.push_fixed(self.surface_x);
        __packet.push_fixed(self.surface_y);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_pointer_v10_event_enter_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_pointer_v10_event_enter_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_pointer_v10_event_enter_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_pointer_v10_event_leave_args {
    serial: u32,
    surface: ::std::option::Option<crate::ObjectId>,
}
impl wl_pointer_v10_event_leave_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_pointer_v10_event_leave_args, crate::Error> {
        let mut __reader = __value.read();
        let serial = __reader.read_uint()?;
        let surface = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { serial, surface })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.serial);
        __packet.push_object(self.surface);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_pointer_v10_event_leave_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_pointer_v10_event_leave_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_pointer_v10_event_leave_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_pointer_v10_event_motion_args {
    time: u32,
    surface_x: crate::Fixed,
    surface_y: crate::Fixed,
}
impl wl_pointer_v10_event_motion_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_pointer_v10_event_motion_args, crate::Error> {
        let mut __reader = __value.read();
        let time = __reader.read_uint()?;
        let surface_x = __reader.read_fixed()?;
        let surface_y = __reader.read_fixed()?;
        __reader.finish()?;
        Ok(Self {
            time,
            surface_x,
            surface_y,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.time);
        __packet.push_fixed(self.surface_x);
        __packet.push_fixed(self.surface_y);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_pointer_v10_event_motion_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_pointer_v10_event_motion_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_pointer_v10_event_motion_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_pointer_v10_event_button_args {
    serial: u32,
    time: u32,
    button: u32,
    state: u32,
}
impl wl_pointer_v10_event_button_args {
    pub const OPCODE: u16 = 3;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_pointer_v10_event_button_args, crate::Error> {
        let mut __reader = __value.read();
        let serial = __reader.read_uint()?;
        let time = __reader.read_uint()?;
        let button = __reader.read_uint()?;
        let state = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self {
            serial,
            time,
            button,
            state,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.serial);
        __packet.push_uint(self.time);
        __packet.push_uint(self.button);
        __packet.push_uint(self.state);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_pointer_v10_event_button_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_pointer_v10_event_button_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_pointer_v10_event_button_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_pointer_v10_event_axis_args {
    time: u32,
    axis: u32,
    value: crate::Fixed,
}
impl wl_pointer_v10_event_axis_args {
    pub const OPCODE: u16 = 4;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_pointer_v10_event_axis_args, crate::Error> {
        let mut __reader = __value.read();
        let time = __reader.read_uint()?;
        let axis = __reader.read_uint()?;
        let value = __reader.read_fixed()?;
        __reader.finish()?;
        Ok(Self { time, axis, value })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.time);
        __packet.push_uint(self.axis);
        __packet.push_fixed(self.value);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_pointer_v10_event_axis_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_pointer_v10_event_axis_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_pointer_v10_event_axis_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_pointer_v10_event_frame_args {}
impl wl_pointer_v10_event_frame_args {
    pub const OPCODE: u16 = 5;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_pointer_v10_event_frame_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_pointer_v10_event_frame_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_pointer_v10_event_frame_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_pointer_v10_event_frame_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_pointer_v10_event_axis_source_args {
    axis_source: u32,
}
impl wl_pointer_v10_event_axis_source_args {
    pub const OPCODE: u16 = 6;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_pointer_v10_event_axis_source_args, crate::Error> {
        let mut __reader = __value.read();
        let axis_source = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { axis_source })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.axis_source);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_pointer_v10_event_axis_source_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_pointer_v10_event_axis_source_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_pointer_v10_event_axis_source_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_pointer_v10_event_axis_stop_args {
    time: u32,
    axis: u32,
}
impl wl_pointer_v10_event_axis_stop_args {
    pub const OPCODE: u16 = 7;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_pointer_v10_event_axis_stop_args, crate::Error> {
        let mut __reader = __value.read();
        let time = __reader.read_uint()?;
        let axis = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { time, axis })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.time);
        __packet.push_uint(self.axis);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_pointer_v10_event_axis_stop_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_pointer_v10_event_axis_stop_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_pointer_v10_event_axis_stop_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_pointer_v10_event_axis_discrete_args {
    axis: u32,
    discrete: i32,
}
impl wl_pointer_v10_event_axis_discrete_args {
    pub const OPCODE: u16 = 8;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_pointer_v10_event_axis_discrete_args, crate::Error> {
        let mut __reader = __value.read();
        let axis = __reader.read_uint()?;
        let discrete = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self { axis, discrete })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.axis);
        __packet.push_int(self.discrete);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_pointer_v10_event_axis_discrete_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_pointer_v10_event_axis_discrete_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_pointer_v10_event_axis_discrete_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_pointer_v10_event_axis_value120_args {
    axis: u32,
    value120: i32,
}
impl wl_pointer_v10_event_axis_value120_args {
    pub const OPCODE: u16 = 9;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_pointer_v10_event_axis_value120_args, crate::Error> {
        let mut __reader = __value.read();
        let axis = __reader.read_uint()?;
        let value120 = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self { axis, value120 })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.axis);
        __packet.push_int(self.value120);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_pointer_v10_event_axis_value120_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_pointer_v10_event_axis_value120_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_pointer_v10_event_axis_value120_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_pointer_v10_event_axis_relative_direction_args {
    axis: u32,
    direction: u32,
}
impl wl_pointer_v10_event_axis_relative_direction_args {
    pub const OPCODE: u16 = 10;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_pointer_v10_event_axis_relative_direction_args, crate::Error> {
        let mut __reader = __value.read();
        let axis = __reader.read_uint()?;
        let direction = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { axis, direction })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.axis);
        __packet.push_uint(self.direction);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_pointer_v10_event_axis_relative_direction_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_pointer_v10_event_axis_relative_direction_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_pointer_v10_event_axis_relative_direction_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait wl_keyboard_v10_event_handler: crate::protocol::EventHandler {
    fn handle_keymap(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        format: u32,
        fd: ::std::os::fd::RawFd,
        size: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_enter(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        surface: ::std::option::Option<crate::ObjectId>,
        keys: ::std::vec::Vec<u8>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_leave(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        surface: ::std::option::Option<crate::ObjectId>,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_key(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        time: u32,
        key: u32,
        state: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_modifiers(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        mods_depressed: u32,
        mods_latched: u32,
        mods_locked: u32,
        group: u32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_repeat_info(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        rate: i32,
        delay: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let format = __packet_reader.read_uint()?;
                    let fd = __packet_reader.read_fd()?;
                    let size = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_keymap(__connection, __packet, format, fd, size)
                        .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let surface = __packet_reader.read_object()?;
                    let keys = __packet_reader.read_array()?;
                    __packet_reader.finish()?;
                    self.handle_enter(__connection, __packet, serial, surface, keys)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let surface = __packet_reader.read_object()?;
                    __packet_reader.finish()?;
                    self.handle_leave(__connection, __packet, serial, surface)
                        .await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let time = __packet_reader.read_uint()?;
                    let key = __packet_reader.read_uint()?;
                    let state = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_key(__connection, __packet, serial, time, key, state)
                        .await;
                    Ok(())
                }
                4 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let mods_depressed = __packet_reader.read_uint()?;
                    let mods_latched = __packet_reader.read_uint()?;
                    let mods_locked = __packet_reader.read_uint()?;
                    let group = __packet_reader.read_uint()?;
                    __packet_reader.finish()?;
                    self.handle_modifiers(
                        __connection,
                        __packet,
                        serial,
                        mods_depressed,
                        mods_latched,
                        mods_locked,
                        group,
                    )
                    .await;
                    Ok(())
                }
                5 => {
                    let mut __packet_reader = __packet.read();
                    let rate = __packet_reader.read_int()?;
                    let delay = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_repeat_info(__connection, __packet, rate, delay)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_keyboard_v10_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_keyboard_v10_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_release(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_keyboard_v10_request_release_args {}
impl wl_keyboard_v10_request_release_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_keyboard_v10_request_release_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_keyboard_v10_request_release_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_keyboard_v10_request_release_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_keyboard_v10_request_release_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_keyboard_v10_event_keymap_args {
    format: u32,
    fd: ::std::os::fd::RawFd,
    size: u32,
}
impl wl_keyboard_v10_event_keymap_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_keyboard_v10_event_keymap_args, crate::Error> {
        let mut __reader = __value.read();
        let format = __reader.read_uint()?;
        let fd = __reader.read_fd()?;
        let size = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self { format, fd, size })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.format);
        __packet.push_fd(self.fd);
        __packet.push_uint(self.size);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_keyboard_v10_event_keymap_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_keyboard_v10_event_keymap_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_keyboard_v10_event_keymap_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_keyboard_v10_event_enter_args {
    serial: u32,
    surface: ::std::option::Option<crate::ObjectId>,
    keys: ::std::vec::Vec<u8>,
}
impl wl_keyboard_v10_event_enter_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_keyboard_v10_event_enter_args, crate::Error> {
        let mut __reader = __value.read();
        let serial = __reader.read_uint()?;
        let surface = __reader.read_object()?;
        let keys = __reader.read_array()?;
        __reader.finish()?;
        Ok(Self {
            serial,
            surface,
            keys,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.serial);
        __packet.push_object(self.surface);
        __packet.push_array(&self.keys);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_keyboard_v10_event_enter_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_keyboard_v10_event_enter_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_keyboard_v10_event_enter_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_keyboard_v10_event_leave_args {
    serial: u32,
    surface: ::std::option::Option<crate::ObjectId>,
}
impl wl_keyboard_v10_event_leave_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_keyboard_v10_event_leave_args, crate::Error> {
        let mut __reader = __value.read();
        let serial = __reader.read_uint()?;
        let surface = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { serial, surface })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.serial);
        __packet.push_object(self.surface);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_keyboard_v10_event_leave_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_keyboard_v10_event_leave_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_keyboard_v10_event_leave_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_keyboard_v10_event_key_args {
    serial: u32,
    time: u32,
    key: u32,
    state: u32,
}
impl wl_keyboard_v10_event_key_args {
    pub const OPCODE: u16 = 3;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_keyboard_v10_event_key_args, crate::Error> {
        let mut __reader = __value.read();
        let serial = __reader.read_uint()?;
        let time = __reader.read_uint()?;
        let key = __reader.read_uint()?;
        let state = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self {
            serial,
            time,
            key,
            state,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.serial);
        __packet.push_uint(self.time);
        __packet.push_uint(self.key);
        __packet.push_uint(self.state);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_keyboard_v10_event_key_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_keyboard_v10_event_key_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_keyboard_v10_event_key_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_keyboard_v10_event_modifiers_args {
    serial: u32,
    mods_depressed: u32,
    mods_latched: u32,
    mods_locked: u32,
    group: u32,
}
impl wl_keyboard_v10_event_modifiers_args {
    pub const OPCODE: u16 = 4;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_keyboard_v10_event_modifiers_args, crate::Error> {
        let mut __reader = __value.read();
        let serial = __reader.read_uint()?;
        let mods_depressed = __reader.read_uint()?;
        let mods_latched = __reader.read_uint()?;
        let mods_locked = __reader.read_uint()?;
        let group = __reader.read_uint()?;
        __reader.finish()?;
        Ok(Self {
            serial,
            mods_depressed,
            mods_latched,
            mods_locked,
            group,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.serial);
        __packet.push_uint(self.mods_depressed);
        __packet.push_uint(self.mods_latched);
        __packet.push_uint(self.mods_locked);
        __packet.push_uint(self.group);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_keyboard_v10_event_modifiers_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_keyboard_v10_event_modifiers_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_keyboard_v10_event_modifiers_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_keyboard_v10_event_repeat_info_args {
    rate: i32,
    delay: i32,
}
impl wl_keyboard_v10_event_repeat_info_args {
    pub const OPCODE: u16 = 5;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_keyboard_v10_event_repeat_info_args, crate::Error> {
        let mut __reader = __value.read();
        let rate = __reader.read_int()?;
        let delay = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self { rate, delay })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.rate);
        __packet.push_int(self.delay);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_keyboard_v10_event_repeat_info_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_keyboard_v10_event_repeat_info_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_keyboard_v10_event_repeat_info_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait wl_touch_v10_event_handler: crate::protocol::EventHandler {
    fn handle_down(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        time: u32,
        surface: ::std::option::Option<crate::ObjectId>,
        id: i32,
        x: crate::Fixed,
        y: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_up(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        serial: u32,
        time: u32,
        id: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_motion(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        time: u32,
        id: i32,
        x: crate::Fixed,
        y: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_frame(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_cancel(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_shape(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        id: i32,
        major: crate::Fixed,
        minor: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_orientation(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        id: i32,
        orientation: crate::Fixed,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let time = __packet_reader.read_uint()?;
                    let surface = __packet_reader.read_object()?;
                    let id = __packet_reader.read_int()?;
                    let x = __packet_reader.read_fixed()?;
                    let y = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_down(__connection, __packet, serial, time, surface, id, x, y)
                        .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let serial = __packet_reader.read_uint()?;
                    let time = __packet_reader.read_uint()?;
                    let id = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_up(__connection, __packet, serial, time, id)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    let time = __packet_reader.read_uint()?;
                    let id = __packet_reader.read_int()?;
                    let x = __packet_reader.read_fixed()?;
                    let y = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_motion(__connection, __packet, time, id, x, y)
                        .await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_frame(__connection, __packet).await;
                    Ok(())
                }
                4 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_cancel(__connection, __packet).await;
                    Ok(())
                }
                5 => {
                    let mut __packet_reader = __packet.read();
                    let id = __packet_reader.read_int()?;
                    let major = __packet_reader.read_fixed()?;
                    let minor = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_shape(__connection, __packet, id, major, minor)
                        .await;
                    Ok(())
                }
                6 => {
                    let mut __packet_reader = __packet.read();
                    let id = __packet_reader.read_int()?;
                    let orientation = __packet_reader.read_fixed()?;
                    __packet_reader.finish()?;
                    self.handle_orientation(__connection, __packet, id, orientation)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_touch_v10_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_touch_v10_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_release(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_touch_v10_request_release_args {}
impl wl_touch_v10_request_release_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_touch_v10_request_release_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_touch_v10_request_release_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_touch_v10_request_release_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_touch_v10_request_release_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_touch_v10_event_down_args {
    serial: u32,
    time: u32,
    surface: ::std::option::Option<crate::ObjectId>,
    id: i32,
    x: crate::Fixed,
    y: crate::Fixed,
}
impl wl_touch_v10_event_down_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_touch_v10_event_down_args, crate::Error> {
        let mut __reader = __value.read();
        let serial = __reader.read_uint()?;
        let time = __reader.read_uint()?;
        let surface = __reader.read_object()?;
        let id = __reader.read_int()?;
        let x = __reader.read_fixed()?;
        let y = __reader.read_fixed()?;
        __reader.finish()?;
        Ok(Self {
            serial,
            time,
            surface,
            id,
            x,
            y,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.serial);
        __packet.push_uint(self.time);
        __packet.push_object(self.surface);
        __packet.push_int(self.id);
        __packet.push_fixed(self.x);
        __packet.push_fixed(self.y);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_touch_v10_event_down_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_touch_v10_event_down_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_touch_v10_event_down_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_touch_v10_event_up_args {
    serial: u32,
    time: u32,
    id: i32,
}
impl wl_touch_v10_event_up_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_touch_v10_event_up_args, crate::Error> {
        let mut __reader = __value.read();
        let serial = __reader.read_uint()?;
        let time = __reader.read_uint()?;
        let id = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self { serial, time, id })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.serial);
        __packet.push_uint(self.time);
        __packet.push_int(self.id);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_touch_v10_event_up_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_touch_v10_event_up_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_touch_v10_event_up_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_touch_v10_event_motion_args {
    time: u32,
    id: i32,
    x: crate::Fixed,
    y: crate::Fixed,
}
impl wl_touch_v10_event_motion_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_touch_v10_event_motion_args, crate::Error> {
        let mut __reader = __value.read();
        let time = __reader.read_uint()?;
        let id = __reader.read_int()?;
        let x = __reader.read_fixed()?;
        let y = __reader.read_fixed()?;
        __reader.finish()?;
        Ok(Self { time, id, x, y })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.time);
        __packet.push_int(self.id);
        __packet.push_fixed(self.x);
        __packet.push_fixed(self.y);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_touch_v10_event_motion_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_touch_v10_event_motion_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_touch_v10_event_motion_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_touch_v10_event_frame_args {}
impl wl_touch_v10_event_frame_args {
    pub const OPCODE: u16 = 3;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_touch_v10_event_frame_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_touch_v10_event_frame_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_touch_v10_event_frame_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_touch_v10_event_frame_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_touch_v10_event_cancel_args {}
impl wl_touch_v10_event_cancel_args {
    pub const OPCODE: u16 = 4;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_touch_v10_event_cancel_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_touch_v10_event_cancel_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_touch_v10_event_cancel_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_touch_v10_event_cancel_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_touch_v10_event_shape_args {
    id: i32,
    major: crate::Fixed,
    minor: crate::Fixed,
}
impl wl_touch_v10_event_shape_args {
    pub const OPCODE: u16 = 5;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_touch_v10_event_shape_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_int()?;
        let major = __reader.read_fixed()?;
        let minor = __reader.read_fixed()?;
        __reader.finish()?;
        Ok(Self { id, major, minor })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.id);
        __packet.push_fixed(self.major);
        __packet.push_fixed(self.minor);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_touch_v10_event_shape_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_touch_v10_event_shape_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_touch_v10_event_shape_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_touch_v10_event_orientation_args {
    id: i32,
    orientation: crate::Fixed,
}
impl wl_touch_v10_event_orientation_args {
    pub const OPCODE: u16 = 6;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_touch_v10_event_orientation_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_int()?;
        let orientation = __reader.read_fixed()?;
        __reader.finish()?;
        Ok(Self { id, orientation })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.id);
        __packet.push_fixed(self.orientation);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_touch_v10_event_orientation_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_touch_v10_event_orientation_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_touch_v10_event_orientation_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub trait wl_output_v4_event_handler: crate::protocol::EventHandler {
    fn handle_geometry(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        x: i32,
        y: i32,
        physical_width: i32,
        physical_height: i32,
        subpixel: i32,
        make: ::std::string::String,
        model: ::std::string::String,
        transform: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_mode(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        flags: u32,
        width: i32,
        height: i32,
        refresh: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_done(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_scale(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        factor: i32,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_name(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        name: ::std::string::String,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn handle_description(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
        description: ::std::string::String,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync;
    fn unknown_event(
        &self,
        connection: &crate::Connection,
        packet: crate::Packet,
    ) -> impl ::std::future::Future<Output = ()> + ::std::marker::Send + ::std::marker::Sync {
        let _ = connection;
        let _ = packet;
        ::std::future::ready(())
    }
    fn handle_event(
        &self,
        __connection: &crate::Connection,
        __packet: crate::Packet,
    ) -> impl std::future::Future<Output = ::std::result::Result<(), crate::Error>>
           + ::std::marker::Send
           + ::std::marker::Sync
    where
        Self: Sync,
    {
        async {
            match __packet.opcode() {
                0 => {
                    let mut __packet_reader = __packet.read();
                    let x = __packet_reader.read_int()?;
                    let y = __packet_reader.read_int()?;
                    let physical_width = __packet_reader.read_int()?;
                    let physical_height = __packet_reader.read_int()?;
                    let subpixel = __packet_reader.read_int()?;
                    let make = __packet_reader.read_str()?;
                    let model = __packet_reader.read_str()?;
                    let transform = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_geometry(
                        __connection,
                        __packet,
                        x,
                        y,
                        physical_width,
                        physical_height,
                        subpixel,
                        make,
                        model,
                        transform,
                    )
                    .await;
                    Ok(())
                }
                1 => {
                    let mut __packet_reader = __packet.read();
                    let flags = __packet_reader.read_uint()?;
                    let width = __packet_reader.read_int()?;
                    let height = __packet_reader.read_int()?;
                    let refresh = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_mode(__connection, __packet, flags, width, height, refresh)
                        .await;
                    Ok(())
                }
                2 => {
                    let mut __packet_reader = __packet.read();
                    __packet_reader.finish()?;
                    self.handle_done(__connection, __packet).await;
                    Ok(())
                }
                3 => {
                    let mut __packet_reader = __packet.read();
                    let factor = __packet_reader.read_int()?;
                    __packet_reader.finish()?;
                    self.handle_scale(__connection, __packet, factor).await;
                    Ok(())
                }
                4 => {
                    let mut __packet_reader = __packet.read();
                    let name = __packet_reader.read_str()?;
                    __packet_reader.finish()?;
                    self.handle_name(__connection, __packet, name).await;
                    Ok(())
                }
                5 => {
                    let mut __packet_reader = __packet.read();
                    let description = __packet_reader.read_str()?;
                    __packet_reader.finish()?;
                    self.handle_description(__connection, __packet, description)
                        .await;
                    Ok(())
                }
                __other => {
                    self.unknown_event(__connection, __packet).await;
                    Ok(())
                }
            }
        }
    }
}
#[allow(unused)]
pub struct wl_output_v4_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_output_v4_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_release(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_output_v4_request_release_args {}
impl wl_output_v4_request_release_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_output_v4_request_release_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_output_v4_request_release_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_output_v4_request_release_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_output_v4_request_release_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_output_v4_event_geometry_args {
    x: i32,
    y: i32,
    physical_width: i32,
    physical_height: i32,
    subpixel: i32,
    make: ::std::string::String,
    model: ::std::string::String,
    transform: i32,
}
impl wl_output_v4_event_geometry_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_output_v4_event_geometry_args, crate::Error> {
        let mut __reader = __value.read();
        let x = __reader.read_int()?;
        let y = __reader.read_int()?;
        let physical_width = __reader.read_int()?;
        let physical_height = __reader.read_int()?;
        let subpixel = __reader.read_int()?;
        let make = __reader.read_str()?;
        let model = __reader.read_str()?;
        let transform = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self {
            x,
            y,
            physical_width,
            physical_height,
            subpixel,
            make,
            model,
            transform,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.x);
        __packet.push_int(self.y);
        __packet.push_int(self.physical_width);
        __packet.push_int(self.physical_height);
        __packet.push_int(self.subpixel);
        __packet.push_str(&self.make);
        __packet.push_str(&self.model);
        __packet.push_int(self.transform);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_output_v4_event_geometry_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_output_v4_event_geometry_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_output_v4_event_geometry_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_output_v4_event_mode_args {
    flags: u32,
    width: i32,
    height: i32,
    refresh: i32,
}
impl wl_output_v4_event_mode_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_output_v4_event_mode_args, crate::Error> {
        let mut __reader = __value.read();
        let flags = __reader.read_uint()?;
        let width = __reader.read_int()?;
        let height = __reader.read_int()?;
        let refresh = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self {
            flags,
            width,
            height,
            refresh,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_uint(self.flags);
        __packet.push_int(self.width);
        __packet.push_int(self.height);
        __packet.push_int(self.refresh);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_output_v4_event_mode_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_output_v4_event_mode_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_output_v4_event_mode_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_output_v4_event_done_args {}
impl wl_output_v4_event_done_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_output_v4_event_done_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_output_v4_event_done_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_output_v4_event_done_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_output_v4_event_done_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_output_v4_event_scale_args {
    factor: i32,
}
impl wl_output_v4_event_scale_args {
    pub const OPCODE: u16 = 3;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_output_v4_event_scale_args, crate::Error> {
        let mut __reader = __value.read();
        let factor = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self { factor })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.factor);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_output_v4_event_scale_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_output_v4_event_scale_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_output_v4_event_scale_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_output_v4_event_name_args {
    name: ::std::string::String,
}
impl wl_output_v4_event_name_args {
    pub const OPCODE: u16 = 4;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_output_v4_event_name_args, crate::Error> {
        let mut __reader = __value.read();
        let name = __reader.read_str()?;
        __reader.finish()?;
        Ok(Self { name })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_str(&self.name);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_output_v4_event_name_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_output_v4_event_name_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_output_v4_event_name_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_output_v4_event_description_args {
    description: ::std::string::String,
}
impl wl_output_v4_event_description_args {
    pub const OPCODE: u16 = 5;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_output_v4_event_description_args, crate::Error> {
        let mut __reader = __value.read();
        let description = __reader.read_str()?;
        __reader.finish()?;
        Ok(Self { description })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_str(&self.description);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_output_v4_event_description_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_output_v4_event_description_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_output_v4_event_description_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub struct wl_region_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_region_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_add(
        &self,
        __object_id: crate::ObjectId,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_int(width);
        __packet.push_int(height);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_subtract(
        &self,
        __object_id: crate::ObjectId,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_int(x);
        __packet.push_int(y);
        __packet.push_int(width);
        __packet.push_int(height);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_region_v1_request_destroy_args {}
impl wl_region_v1_request_destroy_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_region_v1_request_destroy_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_region_v1_request_destroy_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_region_v1_request_destroy_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_region_v1_request_destroy_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_region_v1_request_add_args {
    x: i32,
    y: i32,
    width: i32,
    height: i32,
}
impl wl_region_v1_request_add_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_region_v1_request_add_args, crate::Error> {
        let mut __reader = __value.read();
        let x = __reader.read_int()?;
        let y = __reader.read_int()?;
        let width = __reader.read_int()?;
        let height = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self {
            x,
            y,
            width,
            height,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.x);
        __packet.push_int(self.y);
        __packet.push_int(self.width);
        __packet.push_int(self.height);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_region_v1_request_add_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_region_v1_request_add_args)> for crate::Packet {
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_region_v1_request_add_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_region_v1_request_subtract_args {
    x: i32,
    y: i32,
    width: i32,
    height: i32,
}
impl wl_region_v1_request_subtract_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_region_v1_request_subtract_args, crate::Error> {
        let mut __reader = __value.read();
        let x = __reader.read_int()?;
        let y = __reader.read_int()?;
        let width = __reader.read_int()?;
        let height = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self {
            x,
            y,
            width,
            height,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.x);
        __packet.push_int(self.y);
        __packet.push_int(self.width);
        __packet.push_int(self.height);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_region_v1_request_subtract_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_region_v1_request_subtract_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_region_v1_request_subtract_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub struct wl_subcompositor_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_subcompositor_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_get_subsurface(
        &self,
        __object_id: crate::ObjectId,
        id: crate::NewObjectId,
        surface: ::std::option::Option<crate::ObjectId>,
        parent: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_new_id_known_interface(id);
        __packet.push_object(surface);
        __packet.push_object(parent);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_subcompositor_v1_request_destroy_args {}
impl wl_subcompositor_v1_request_destroy_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_subcompositor_v1_request_destroy_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_subcompositor_v1_request_destroy_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_subcompositor_v1_request_destroy_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_subcompositor_v1_request_destroy_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_subcompositor_v1_request_get_subsurface_args {
    id: crate::NewObjectId,
    surface: ::std::option::Option<crate::ObjectId>,
    parent: ::std::option::Option<crate::ObjectId>,
}
impl wl_subcompositor_v1_request_get_subsurface_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_subcompositor_v1_request_get_subsurface_args, crate::Error> {
        let mut __reader = __value.read();
        let id = __reader.read_new_id_known_interface()?;
        let surface = __reader.read_object()?;
        let parent = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self {
            id,
            surface,
            parent,
        })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_new_id_known_interface(self.id);
        __packet.push_object(self.surface);
        __packet.push_object(self.parent);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_subcompositor_v1_request_get_subsurface_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl
    ::std::convert::TryFrom<(
        crate::ObjectId,
        wl_subcompositor_v1_request_get_subsurface_args,
    )> for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (
            crate::ObjectId,
            wl_subcompositor_v1_request_get_subsurface_args,
        ),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub struct wl_subsurface_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_subsurface_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_position(
        &self,
        __object_id: crate::ObjectId,
        x: i32,
        y: i32,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_int(x);
        __packet.push_int(y);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_place_above(
        &self,
        __object_id: crate::ObjectId,
        sibling: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 2);
        __packet.push_object(sibling);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_place_below(
        &self,
        __object_id: crate::ObjectId,
        sibling: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 3);
        __packet.push_object(sibling);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_sync(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 4);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_set_desync(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 5);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_subsurface_v1_request_destroy_args {}
impl wl_subsurface_v1_request_destroy_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_subsurface_v1_request_destroy_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_subsurface_v1_request_destroy_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_subsurface_v1_request_destroy_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_subsurface_v1_request_destroy_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_subsurface_v1_request_set_position_args {
    x: i32,
    y: i32,
}
impl wl_subsurface_v1_request_set_position_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_subsurface_v1_request_set_position_args, crate::Error> {
        let mut __reader = __value.read();
        let x = __reader.read_int()?;
        let y = __reader.read_int()?;
        __reader.finish()?;
        Ok(Self { x, y })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_int(self.x);
        __packet.push_int(self.y);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_subsurface_v1_request_set_position_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_subsurface_v1_request_set_position_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_subsurface_v1_request_set_position_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_subsurface_v1_request_place_above_args {
    sibling: ::std::option::Option<crate::ObjectId>,
}
impl wl_subsurface_v1_request_place_above_args {
    pub const OPCODE: u16 = 2;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_subsurface_v1_request_place_above_args, crate::Error> {
        let mut __reader = __value.read();
        let sibling = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { sibling })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.sibling);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_subsurface_v1_request_place_above_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_subsurface_v1_request_place_above_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_subsurface_v1_request_place_above_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_subsurface_v1_request_place_below_args {
    sibling: ::std::option::Option<crate::ObjectId>,
}
impl wl_subsurface_v1_request_place_below_args {
    pub const OPCODE: u16 = 3;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_subsurface_v1_request_place_below_args, crate::Error> {
        let mut __reader = __value.read();
        let sibling = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { sibling })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.sibling);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_subsurface_v1_request_place_below_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_subsurface_v1_request_place_below_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_subsurface_v1_request_place_below_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_subsurface_v1_request_set_sync_args {}
impl wl_subsurface_v1_request_set_sync_args {
    pub const OPCODE: u16 = 4;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_subsurface_v1_request_set_sync_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_subsurface_v1_request_set_sync_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_subsurface_v1_request_set_sync_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_subsurface_v1_request_set_sync_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_subsurface_v1_request_set_desync_args {}
impl wl_subsurface_v1_request_set_desync_args {
    pub const OPCODE: u16 = 5;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_subsurface_v1_request_set_desync_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_subsurface_v1_request_set_desync_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_subsurface_v1_request_set_desync_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_subsurface_v1_request_set_desync_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
#[allow(unused)]
pub struct wl_fixes_v1_request_proxy<'a> {
    connection: &'a crate::Connection,
}
#[allow(unused)]
impl<'a> wl_fixes_v1_request_proxy<'a> {
    pub fn new(connection: &'a crate::Connection) -> Self {
        Self { connection }
    }
    pub async fn send_destroy(&self, __object_id: crate::ObjectId) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 0);
        self.connection.send_packet(&__packet).await
    }
    pub async fn send_destroy_registry(
        &self,
        __object_id: crate::ObjectId,
        registry: ::std::option::Option<crate::ObjectId>,
    ) -> Result<(), crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, 1);
        __packet.push_object(registry);
        self.connection.send_packet(&__packet).await
    }
}
pub struct wl_fixes_v1_request_destroy_args {}
impl wl_fixes_v1_request_destroy_args {
    pub const OPCODE: u16 = 0;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_fixes_v1_request_destroy_args, crate::Error> {
        let mut __reader = __value.read();
        __reader.finish()?;
        Ok(Self {})
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_fixes_v1_request_destroy_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_fixes_v1_request_destroy_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_fixes_v1_request_destroy_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
pub struct wl_fixes_v1_request_destroy_registry_args {
    registry: ::std::option::Option<crate::ObjectId>,
}
impl wl_fixes_v1_request_destroy_registry_args {
    pub const OPCODE: u16 = 1;
    pub fn try_from_packet(
        __value: &crate::Packet,
    ) -> Result<wl_fixes_v1_request_destroy_registry_args, crate::Error> {
        let mut __reader = __value.read();
        let registry = __reader.read_object()?;
        __reader.finish()?;
        Ok(Self { registry })
    }
    pub fn try_into_packet(
        &self,
        __object_id: crate::ObjectId,
    ) -> Result<crate::Packet, crate::Error> {
        let mut __packet = crate::Packet::new(__object_id, Self::OPCODE);
        __packet.push_object(self.registry);
        Ok(__packet)
    }
}
impl ::std::convert::TryFrom<crate::Packet> for wl_fixes_v1_request_destroy_registry_args {
    type Error = crate::Error;
    fn try_from(__value: crate::Packet) -> Result<Self, Self::Error> {
        Self::try_from_packet(&__value)
    }
}
impl ::std::convert::TryFrom<(crate::ObjectId, wl_fixes_v1_request_destroy_registry_args)>
    for crate::Packet
{
    type Error = crate::Error;
    fn try_from(
        __value: (crate::ObjectId, wl_fixes_v1_request_destroy_registry_args),
    ) -> Result<Self, Self::Error> {
        let (__object_id, __structure) = __value;
        __structure.try_into_packet(__object_id)
    }
}
